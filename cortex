#!/bin/bash
#
# Cortex MCP Server Wrapper - Singleton Daemon Architecture
#
# Usage:
#   cortex              - Default: auto-start daemon if needed, run bridge
#   cortex init         - Interactive setup, creates ~/.cortex/settings.json
#   cortex config       - Show current configuration
#   cortex config edit  - Open settings.json in $EDITOR
#   cortex daemon start - Start the daemon
#   cortex daemon stop  - Stop the daemon
#   cortex daemon restart - Restart the daemon
#   cortex daemon status - Check daemon status
#   cortex daemon logs  - View daemon logs
#   cortex stdio        - Run in legacy stdio mode (no daemon)
#
# Configuration:
#   Settings are stored in ~/.cortex/settings.json
#   Run 'cortex init' to create this file interactively.
#
# Environment variables (override settings.json):
#   CORTEX_CODE_PATHS    - Comma-separated list of code directories to mount
#   CORTEX_DATA_PATH     - Where to store Cortex data (default: ~/.cortex)
#   CORTEX_HEADER_PROVIDER - Header provider: "anthropic", "claude-cli", or "none"
#   CORTEX_DEBUG         - Enable debug logging (true/false)
#   CORTEX_DAEMON_PORT   - Daemon port (default: 8000)
#   ANTHROPIC_API_KEY    - Required for header_provider="anthropic"
#

# --- Configuration ---
DAEMON_CONTAINER_NAME="cortex-daemon"
DAEMON_PORT="${CORTEX_DAEMON_PORT:-8000}"
HTTP_PORT="${CORTEX_HTTP_PORT:-8080}"
IMAGE_NAME="cortex"

# Defaults
DATA_PATH="${CORTEX_DATA_PATH:-$HOME/.cortex}"
CODE_PATHS="${CORTEX_CODE_PATHS:-}"

# Expand ~ in paths
DATA_PATH="${DATA_PATH/#\~/$HOME}"

# --- Find the Cortex source directory ---
get_script_dir() {
    local source="${BASH_SOURCE[0]}"
    while [ -L "$source" ]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

CORTEX_SRC_DIR="$(get_script_dir)"

# Settings file location
SETTINGS_FILE="$DATA_PATH/settings.json"

# Settings values (loaded from file, can be overridden by env vars)
SETTINGS_CODE_PATHS=""
SETTINGS_HEADER_PROVIDER=""
SETTINGS_DEBUG=""

# Track env var overrides (for display purposes)
ENV_OVERRIDE_CODE_PATHS=""
ENV_OVERRIDE_HEADER_PROVIDER=""
ENV_OVERRIDE_DEBUG=""

load_settings() {
    # Capture original env vars before loading settings
    local orig_code_paths="$CODE_PATHS"
    local orig_header_provider="$CORTEX_HEADER_PROVIDER"
    local orig_debug="$CORTEX_DEBUG"

    # Load settings from ~/.cortex/settings.json if it exists
    if [ -f "$SETTINGS_FILE" ]; then
        # Parse JSON using python3 (available on most systems)
        local settings
        settings=$(python3 -c "
import json
import sys
try:
    with open('$SETTINGS_FILE') as f:
        s = json.load(f)
    # Output as shell-friendly format
    paths = s.get('code_paths', [])
    if isinstance(paths, list):
        print('CODE_PATHS=' + ','.join(paths))
    print('HEADER_PROVIDER=' + str(s.get('header_provider', '')))
    print('DEBUG=' + str(s.get('debug', '')).lower())
except Exception as e:
    print('ERROR=' + str(e), file=sys.stderr)
    sys.exit(1)
" 2>/dev/null)

        if [ $? -eq 0 ]; then
            # Parse the output
            while IFS='=' read -r key value; do
                case "$key" in
                    CODE_PATHS) SETTINGS_CODE_PATHS="$value" ;;
                    HEADER_PROVIDER) SETTINGS_HEADER_PROVIDER="$value" ;;
                    DEBUG) SETTINGS_DEBUG="$value" ;;
                esac
            done <<< "$settings"
        fi
    fi

    # Apply settings (env vars override settings file)
    if [ -z "$CODE_PATHS" ] && [ -n "$SETTINGS_CODE_PATHS" ]; then
        CODE_PATHS="$SETTINGS_CODE_PATHS"
    elif [ -n "$orig_code_paths" ] && [ -n "$SETTINGS_CODE_PATHS" ]; then
        ENV_OVERRIDE_CODE_PATHS="true"
    fi

    if [ -z "$CORTEX_HEADER_PROVIDER" ] && [ -n "$SETTINGS_HEADER_PROVIDER" ]; then
        CORTEX_HEADER_PROVIDER="$SETTINGS_HEADER_PROVIDER"
    elif [ -n "$orig_header_provider" ] && [ -n "$SETTINGS_HEADER_PROVIDER" ]; then
        ENV_OVERRIDE_HEADER_PROVIDER="true"
    fi

    if [ -z "$CORTEX_DEBUG" ] && [ -n "$SETTINGS_DEBUG" ]; then
        CORTEX_DEBUG="$SETTINGS_DEBUG"
    elif [ -n "$orig_debug" ] && [ -n "$SETTINGS_DEBUG" ]; then
        ENV_OVERRIDE_DEBUG="true"
    fi
}

# Load settings on script start
load_settings

# --- Helper Functions ---

log_info() {
    echo "[cortex] $1" >&2
}

log_error() {
    echo "[cortex] ERROR: $1" >&2
}

build_image() {
    log_info "Building Cortex Docker image..."

    # Capture git commit and build time for version tracking
    local git_commit
    local build_time
    git_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    log_info "Build info: commit=$git_commit, time=$build_time"

    if docker build \
        --build-arg "GIT_COMMIT=$git_commit" \
        --build-arg "BUILD_TIME=$build_time" \
        -t "$IMAGE_NAME" "$CORTEX_SRC_DIR" >&2; then
        log_info "Image built successfully"
    else
        log_error "Failed to build image"
        exit 1
    fi
}

build_image_if_needed() {
    # Build if image doesn't exist or source is newer
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        build_image
    fi
}

is_daemon_running() {
    docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Names}}' 2>/dev/null | grep -q "^${DAEMON_CONTAINER_NAME}$"
}

wait_for_daemon() {
    local max_attempts=30
    local attempt=0
    log_info "Waiting for daemon to be ready..."

    while [ $attempt -lt $max_attempts ]; do
        if curl -sf "http://localhost:${DAEMON_PORT}/health" >/dev/null 2>&1; then
            log_info "Daemon is ready"
            return 0
        fi
        sleep 0.5
        attempt=$((attempt + 1))
    done

    log_error "Daemon failed to start within timeout"
    return 1
}

# Global arrays for docker arguments
DOCKER_VOLUMES=()
DOCKER_ENVS=()

build_docker_volumes() {
    DOCKER_VOLUMES=()

    # Mount data directory (ensure it exists)
    mkdir -p "$DATA_PATH"
    DOCKER_VOLUMES+=("-v" "$DATA_PATH:$DATA_PATH")

    # Mount code paths
    if [ -n "$CODE_PATHS" ]; then
        IFS=',' read -ra PATHS <<< "$CODE_PATHS"
        for path in "${PATHS[@]}"; do
            path="$(echo "$path" | xargs)"
            path="${path/#\~/$HOME}"
            if [ -d "$path" ]; then
                DOCKER_VOLUMES+=("-v" "$path:$path:ro")
            else
                log_info "Warning: Code path does not exist: $path"
            fi
        done
    fi
}

build_docker_env() {
    DOCKER_ENVS=()
    DOCKER_ENVS+=("-e" "CORTEX_DATA_PATH=$DATA_PATH")
    DOCKER_ENVS+=("-e" "CORTEX_DB_PATH=$DATA_PATH/db")
    [ -n "$CORTEX_HEADER_PROVIDER" ] && DOCKER_ENVS+=("-e" "CORTEX_HEADER_PROVIDER=$CORTEX_HEADER_PROVIDER")
    [ -n "$CORTEX_DEBUG" ] && DOCKER_ENVS+=("-e" "CORTEX_DEBUG=$CORTEX_DEBUG")
    [ -n "$ANTHROPIC_API_KEY" ] && DOCKER_ENVS+=("-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
    [ -n "$CORTEX_LOG_FILE" ] && DOCKER_ENVS+=("-e" "CORTEX_LOG_FILE=$CORTEX_LOG_FILE")
}

start_daemon() {
    if is_daemon_running; then
        log_info "Daemon is already running"
        return 0
    fi

    # Clean up any stopped container with the same name
    docker rm "$DAEMON_CONTAINER_NAME" 2>/dev/null || true

    log_info "Starting Cortex daemon..."

    build_docker_volumes
    build_docker_env

    docker run -d \
        --name "$DAEMON_CONTAINER_NAME" \
        --restart unless-stopped \
        -p "${DAEMON_PORT}:8000" \
        -p "${HTTP_PORT}:8080" \
        "${DOCKER_VOLUMES[@]}" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" daemon >&2

    if wait_for_daemon; then
        log_info "Daemon started on port $DAEMON_PORT"
        return 0
    else
        log_error "Daemon failed to start"
        docker logs "$DAEMON_CONTAINER_NAME" >&2
        return 1
    fi
}

stop_daemon() {
    if is_daemon_running; then
        log_info "Stopping Cortex daemon..."
        docker stop "$DAEMON_CONTAINER_NAME" >&2
        docker rm "$DAEMON_CONTAINER_NAME" >&2
        log_info "Daemon stopped"
    else
        log_info "Daemon is not running"
    fi
}

daemon_status() {
    if is_daemon_running; then
        echo "Daemon is running"
        docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo ""
        echo "Build info:"
        curl -s "http://localhost:${DAEMON_PORT}/info" 2>/dev/null || echo "Failed to reach daemon"
        echo ""
        echo ""
        echo "Local HEAD: $(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
    else
        echo "Daemon is not running"
        exit 1
    fi
}

daemon_logs() {
    if is_daemon_running; then
        docker logs -f "$DAEMON_CONTAINER_NAME"
    else
        # Show logs from stopped container if it exists
        docker logs "$DAEMON_CONTAINER_NAME" 2>/dev/null || echo "No logs available"
    fi
}

# --- Configuration Commands ---

init_settings() {
    echo "Cortex Setup"
    echo "============"
    echo ""
    echo "This will create ~/.cortex/settings.json"
    echo ""

    # Ensure data directory exists
    mkdir -p "$DATA_PATH"

    # Collect code paths
    echo "Enter the directories containing code you want to index."
    echo "You can enter multiple paths, one per line."
    echo "Press Enter on an empty line when done."
    echo ""
    echo "Examples:"
    echo "  ~/Projects"
    echo "  ~/Work"
    echo "  /path/to/specific/repo"
    echo ""

    local paths=()
    while true; do
        read -r -p "Code path (or Enter to finish): " path
        if [ -z "$path" ]; then
            break
        fi
        # Expand ~ to $HOME for validation
        local expanded_path="${path/#\~/$HOME}"
        if [ -d "$expanded_path" ]; then
            paths+=("$path")
            echo "  Added: $path"
        else
            echo "  Warning: Directory does not exist: $path"
            read -r -p "  Add anyway? [y/N]: " confirm
            if [[ "$confirm" =~ ^[Yy] ]]; then
                paths+=("$path")
                echo "  Added: $path"
            fi
        fi
    done

    if [ ${#paths[@]} -eq 0 ]; then
        echo ""
        echo "Warning: No code paths configured. You can add them later with:"
        echo "  cortex config edit"
        echo ""
    fi

    # Header provider
    echo ""
    echo "Header Provider (adds AI-generated summaries to code chunks):"
    echo "  none      - No headers (fastest, recommended)"
    echo "  claude-cli - Uses Claude CLI (requires claude to be installed)"
    echo "  anthropic  - Uses Anthropic API (requires ANTHROPIC_API_KEY)"
    echo ""
    read -r -p "Header provider [none]: " header_provider
    header_provider="${header_provider:-none}"

    if [[ ! "$header_provider" =~ ^(none|claude-cli|anthropic)$ ]]; then
        echo "Invalid option, using 'none'"
        header_provider="none"
    fi

    # Debug mode
    echo ""
    read -r -p "Enable debug logging? [y/N]: " debug_input
    local debug="false"
    if [[ "$debug_input" =~ ^[Yy] ]]; then
        debug="true"
    fi

    # Build JSON
    local paths_json="[]"
    if [ ${#paths[@]} -gt 0 ]; then
        paths_json=$(printf '%s\n' "${paths[@]}" | python3 -c "
import json, sys
paths = [line.strip() for line in sys.stdin if line.strip()]
print(json.dumps(paths))
")
    fi

    # Write settings file
    python3 -c "
import json
settings = {
    'code_paths': $paths_json,
    'header_provider': '$header_provider',
    'debug': $debug
}
with open('$SETTINGS_FILE', 'w') as f:
    json.dump(settings, f, indent=2)
    f.write('\n')
"

    echo ""
    echo "Settings saved to: $SETTINGS_FILE"
    echo ""
    cat "$SETTINGS_FILE"
    echo ""

    # Check if daemon needs restart
    if is_daemon_running; then
        echo ""
        echo "Note: Daemon is running. Restart it to apply changes:"
        echo "  cortex daemon restart"
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Add Cortex to Claude Code:"
    echo "     claude mcp add cortex cortex"
    echo ""
    echo "  2. Restart Claude Code to load the MCP server"
    echo ""
}

show_config() {
    echo "Cortex Configuration"
    echo "===================="
    echo ""
    echo "Settings file: $SETTINGS_FILE"
    echo ""

    if [ -f "$SETTINGS_FILE" ]; then
        echo "Current settings:"
        cat "$SETTINGS_FILE"
    else
        echo "No settings file found."
        echo ""
        echo "Run 'cortex init' to create one."
    fi

    echo ""
    echo "Active configuration (after env var overrides):"
    echo "  code_paths: ${CODE_PATHS:-<not set>}"
    echo "  header_provider: ${CORTEX_HEADER_PROVIDER:-<not set>}"
    echo "  debug: ${CORTEX_DEBUG:-<not set>}"
    echo "  data_path: $DATA_PATH"
    echo ""

    # Show any env var overrides
    if [ -n "$ENV_OVERRIDE_CODE_PATHS" ]; then
        echo "Note: CORTEX_CODE_PATHS env var is overriding settings.json"
    fi
    if [ -n "$ENV_OVERRIDE_HEADER_PROVIDER" ]; then
        echo "Note: CORTEX_HEADER_PROVIDER env var is overriding settings.json"
    fi
    if [ -n "$ENV_OVERRIDE_DEBUG" ]; then
        echo "Note: CORTEX_DEBUG env var is overriding settings.json"
    fi
}

edit_config() {
    if [ ! -f "$SETTINGS_FILE" ]; then
        echo "No settings file found. Creating default..."
        mkdir -p "$DATA_PATH"
        echo '{
  "code_paths": [],
  "header_provider": "none",
  "debug": false
}' > "$SETTINGS_FILE"
    fi

    local editor="${EDITOR:-${VISUAL:-vi}}"
    echo "Opening $SETTINGS_FILE with $editor..."
    "$editor" "$SETTINGS_FILE"

    # Validate JSON after editing
    if python3 -c "import json; json.load(open('$SETTINGS_FILE'))" 2>/dev/null; then
        echo "Settings file is valid JSON."
        if is_daemon_running; then
            echo ""
            echo "Note: Restart daemon to apply changes:"
            echo "  cortex daemon restart"
        fi
    else
        echo "Warning: Settings file contains invalid JSON!"
        echo "Please fix the syntax errors."
    fi
}

run_bridge() {
    # Ensure daemon is running
    if ! is_daemon_running; then
        build_image_if_needed
        start_daemon
    fi

    # Build env vars for bridge
    build_docker_env

    # Run bridge in foreground, connecting to daemon
    exec docker run -i --rm \
        --network host \
        -e "CORTEX_DAEMON_URL=http://localhost:${DAEMON_PORT}" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" bridge
}

run_stdio_legacy() {
    # Legacy mode: run stdio MCP server directly (no daemon)
    log_info "Running in legacy stdio mode..."

    build_docker_volumes
    build_docker_env

    exec docker run -i --rm \
        "${DOCKER_VOLUMES[@]}" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" stdio
}

# --- Main Command Handling ---

case "${1:-}" in
    daemon)
        case "${2:-status}" in
            start)
                build_image_if_needed
                start_daemon
                ;;
            stop)
                stop_daemon
                ;;
            restart)
                stop_daemon
                build_image
                start_daemon
                ;;
            status)
                daemon_status
                ;;
            logs)
                daemon_logs
                ;;
            rebuild)
                stop_daemon
                build_image
                start_daemon
                ;;
            *)
                echo "Usage: cortex daemon {start|stop|restart|status|logs|rebuild}" >&2
                exit 1
                ;;
        esac
        ;;
    init)
        init_settings
        ;;
    config)
        case "${2:-}" in
            edit)
                edit_config
                ;;
            ""|show)
                show_config
                ;;
            *)
                echo "Usage: cortex config [show|edit]" >&2
                exit 1
                ;;
        esac
        ;;
    stop)
        stop_daemon
        ;;
    stdio)
        # Legacy stdio mode
        build_image_if_needed
        run_stdio_legacy
        ;;
    logs)
        daemon_logs
        ;;
    rebuild)
        stop_daemon
        build_image
        start_daemon
        ;;
    *)
        # Default: run stdio bridge (auto-starts daemon if needed)
        run_bridge
        ;;
esac
