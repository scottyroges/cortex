#!/bin/bash
#
# Cortex MCP Server Wrapper - Singleton Daemon Architecture
#
# Usage:
#   cortex              - Default: auto-start daemon if needed, run bridge
#   cortex init         - Interactive setup, creates ~/.cortex/config.yaml
#   cortex config       - Show current configuration
#   cortex config edit  - Open config.yaml in $EDITOR
#   cortex daemon start - Start the daemon
#   cortex daemon stop  - Stop the daemon
#   cortex daemon restart - Restart the daemon
#   cortex daemon status - Check daemon status
#   cortex daemon logs  - View daemon logs
#
# Configuration:
#   Settings are stored in ~/.cortex/config.yaml
#   Run 'cortex init' to create this file interactively.
#
# Environment variables (override config.yaml):
#   CORTEX_CODE_PATHS    - Comma-separated list of code directories to mount
#   CORTEX_DEBUG         - Enable debug logging (true/false)
#   CORTEX_PORT          - Server port (default: 8000)
#   ANTHROPIC_API_KEY    - Required for LLM provider="anthropic"
#

# --- Error Handling ---
set -euo pipefail

# Cleanup function for trap handler
_cleanup() {
    # Only clean up summarizer PID if we started it
    if [ -n "${_STARTED_SUMMARIZER:-}" ]; then
        rm -f "$HOME/.cortex/summarizer.pid" 2>/dev/null || true
    fi
}
trap _cleanup EXIT

# --- Configuration ---
DAEMON_CONTAINER_NAME="cortex-daemon"
CORTEX_PORT="${CORTEX_PORT:-8000}"
SUMMARIZER_PORT="${CORTEX_SUMMARIZER_PORT:-8081}"
IMAGE_NAME="cortex"
GHCR_IMAGE="ghcr.io/scottyroges/cortex"

# Summarizer PID file (for claude-cli LLM provider)
SUMMARIZER_PID_FILE="$HOME/.cortex/summarizer.pid"

# Defaults
DATA_PATH="${CORTEX_DATA_PATH:-$HOME/.cortex}"
CODE_PATHS="${CORTEX_CODE_PATHS:-}"

# Expand ~ in paths
DATA_PATH="${DATA_PATH/#\~/$HOME}"

# --- Find the Cortex source directory ---
get_script_dir() {
    local source="${BASH_SOURCE[0]}"
    local iterations=0
    while [ -L "$source" ] && [ $iterations -lt 50 ]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
        iterations=$((iterations + 1))
    done
    if [ $iterations -ge 50 ]; then
        echo "Error: Symlink loop detected" >&2
        exit 1
    fi
    cd -P "$(dirname "$source")" && pwd
}

CORTEX_SRC_DIR="$(get_script_dir)"

# Config file location
CONFIG_FILE="$DATA_PATH/config.yaml"

# Config values (loaded from file, can be overridden by env vars)
CONFIG_CODE_PATHS=""
CONFIG_DEBUG=""
CONFIG_PORT=""
CONFIG_LLM_PROVIDER=""

# Track env var overrides (for display purposes)
ENV_OVERRIDE_CODE_PATHS=""
ENV_OVERRIDE_DEBUG=""
ENV_OVERRIDE_PORT=""

load_config() {
    # Capture original env vars before loading config
    local orig_code_paths="$CODE_PATHS"
    local orig_debug="${CORTEX_DEBUG:-}"
    local orig_port="${CORTEX_PORT:-}"

    # Load config from ~/.cortex/config.yaml if it exists
    if [ -f "$CONFIG_FILE" ]; then
        # Use config parser script for safer YAML parsing
        local config
        if config=$(python3 "$CORTEX_SRC_DIR/scripts/config_parser.py" parse "$CONFIG_FILE" 2>/dev/null); then
            # Parse the output
            while IFS='=' read -r key value; do
                case "$key" in
                    CODE_PATHS) CONFIG_CODE_PATHS="$value" ;;
                    DEBUG) CONFIG_DEBUG="$value" ;;
                    PORT) CONFIG_PORT="$value" ;;
                    LLM_PROVIDER) CONFIG_LLM_PROVIDER="$value" ;;
                esac
            done <<< "$config"
        fi
    fi

    # Apply config (env vars override config file)
    if [ -z "$CODE_PATHS" ] && [ -n "$CONFIG_CODE_PATHS" ]; then
        CODE_PATHS="$CONFIG_CODE_PATHS"
    elif [ -n "$orig_code_paths" ] && [ -n "$CONFIG_CODE_PATHS" ]; then
        ENV_OVERRIDE_CODE_PATHS="true"
    fi

    if [ -z "${CORTEX_DEBUG:-}" ] && [ -n "$CONFIG_DEBUG" ]; then
        CORTEX_DEBUG="$CONFIG_DEBUG"
    elif [ -n "$orig_debug" ] && [ -n "$CONFIG_DEBUG" ]; then
        ENV_OVERRIDE_DEBUG="true"
    fi

    # Apply port config
    if [ -z "${CORTEX_PORT:-}" ] && [ -n "$CONFIG_PORT" ]; then
        CORTEX_PORT="$CONFIG_PORT"
    elif [ -n "$orig_port" ] && [ -n "$CONFIG_PORT" ]; then
        ENV_OVERRIDE_PORT="true"
    fi
}

# Load config on script start
load_config

# --- Helper Functions ---

log_info() {
    echo "[cortex] $1" >&2
}

log_error() {
    echo "[cortex] ERROR: $1" >&2
}

build_image() {
    log_info "Building Cortex Docker image..."

    # Capture git commit and build time for version tracking
    local git_commit
    local build_time
    git_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    log_info "Build info: commit=$git_commit, time=$build_time"

    if docker build \
        --build-arg "GIT_COMMIT=$git_commit" \
        --build-arg "BUILD_TIME=$build_time" \
        -t "$IMAGE_NAME" "$CORTEX_SRC_DIR" >&2; then
        log_info "Image built successfully"
    else
        log_error "Failed to build image"
        exit 1
    fi
}

pull_image() {
    # Pull pre-built image from GHCR
    # Returns 0 on success, 1 on failure
    local tag="${1:-latest}"
    local full_image="$GHCR_IMAGE:$tag"

    log_info "Pulling image from GHCR: $full_image"

    if docker pull "$full_image" >&2; then
        # Tag as local image name for consistency
        docker tag "$full_image" "$IMAGE_NAME" >&2
        log_info "Image pulled and tagged as $IMAGE_NAME"
        return 0
    else
        log_info "Pull failed, will fall back to local build"
        return 1
    fi
}

build_image_if_needed() {
    # Use existing image if available
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        return 0
    fi

    # Try pulling from GHCR first, fall back to local build
    if pull_image; then
        return 0
    fi

    log_info "Building image locally..."
    build_image
}

is_daemon_running() {
    docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Names}}' 2>/dev/null | grep -q "^${DAEMON_CONTAINER_NAME}$"
}

wait_for_daemon() {
    local max_attempts=30
    local attempt=0
    log_info "Waiting for daemon to be ready..."

    while [ $attempt -lt $max_attempts ]; do
        if curl -sf "http://localhost:${CORTEX_PORT}/health" >/dev/null 2>&1; then
            log_info "Daemon is ready"
            return 0
        fi
        sleep 0.5
        attempt=$((attempt + 1))
    done

    log_error "Daemon failed to start within timeout"
    return 1
}

# Global arrays for docker arguments
DOCKER_VOLUMES=()
DOCKER_ENVS=()

build_docker_volumes() {
    DOCKER_VOLUMES=()

    # Mount data directory (ensure it exists)
    mkdir -p "$DATA_PATH"
    mkdir -p "$DATA_PATH/db"
    DOCKER_VOLUMES+=("-v" "$DATA_PATH:$DATA_PATH")
    # Mount the database directory to where Docker code expects it
    DOCKER_VOLUMES+=("-v" "$DATA_PATH/db:/app/cortex_db")

    # Mount code paths
    if [ -n "$CODE_PATHS" ]; then
        IFS=',' read -ra PATHS <<< "$CODE_PATHS"
        for path in "${PATHS[@]}"; do
            path="$(echo "$path" | xargs)"
            path="${path/#\~/$HOME}"
            if [ -d "$path" ]; then
                DOCKER_VOLUMES+=("-v" "$path:$path:ro")
            else
                log_info "Warning: Code path does not exist: $path"
            fi
        done
    fi
}

build_docker_env() {
    DOCKER_ENVS=()
    [ -n "${CORTEX_DEBUG:-}" ] && DOCKER_ENVS+=("-e" "CORTEX_DEBUG=$CORTEX_DEBUG")
    [ -n "${ANTHROPIC_API_KEY:-}" ] && DOCKER_ENVS+=("-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
    [ -n "${OPENROUTER_API_KEY:-}" ] && DOCKER_ENVS+=("-e" "OPENROUTER_API_KEY=$OPENROUTER_API_KEY")
    [ -n "${CORTEX_LOG_FILE:-}" ] && DOCKER_ENVS+=("-e" "CORTEX_LOG_FILE=$CORTEX_LOG_FILE")

    # Determine LLM provider: env var overrides config file
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"

    # Pass the LLM provider setting to the daemon
    DOCKER_ENVS+=("-e" "CORTEX_LLM_PROVIDER=$llm_provider")

    # Pass summarizer URL if using claude-cli
    if [ "$llm_provider" = "claude-cli" ]; then
        # Platform detection for Docker host access
        local docker_host
        if [[ "$(uname)" == "Linux" ]] && ! grep -q "microsoft" /proc/version 2>/dev/null; then
            # Native Linux - use docker bridge gateway IP
            docker_host="172.17.0.1"
        else
            # macOS, Windows, or WSL - use host.docker.internal
            docker_host="host.docker.internal"
        fi
        DOCKER_ENVS+=("-e" "CORTEX_SUMMARIZER_URL=http://${docker_host}:$SUMMARIZER_PORT")
    fi
}

# --- Summarizer Functions (for claude-cli LLM provider) ---

is_summarizer_running() {
    if [ -f "$SUMMARIZER_PID_FILE" ]; then
        local pid
        pid=$(cat "$SUMMARIZER_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

start_summarizer() {
    # Only start if using claude-cli as LLM provider
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"
    if [ "$llm_provider" != "claude-cli" ]; then
        return 0
    fi

    # Check if claude CLI is available
    if ! command -v claude &>/dev/null; then
        log_error "claude-cli is configured as LLM provider but 'claude' CLI not found"
        log_error "Install with: npm install -g @anthropic-ai/claude-code"
        log_error "Or change llm.primary_provider in ~/.cortex/config.yaml"
        return 1
    fi

    if is_summarizer_running; then
        log_info "Summarizer is already running"
        return 0
    fi

    log_info "Starting summarizer proxy on port $SUMMARIZER_PORT..."

    # Ensure data directory exists
    mkdir -p "$DATA_PATH"

    # Start proxy server in background (run from cortex source directory)
    cd "$CORTEX_SRC_DIR"
    nohup python3 -m src.controllers.proxy.server --port "$SUMMARIZER_PORT" \
        > "$DATA_PATH/summarizer.log" 2>&1 &
    local pid=$!
    cd - >/dev/null

    # Wait for health check before writing PID (prevents stale PID files)
    local attempts=0
    while [ $attempts -lt 20 ]; do
        if curl -sf "http://localhost:$SUMMARIZER_PORT/health" >/dev/null 2>&1; then
            echo "$pid" > "$SUMMARIZER_PID_FILE"
            _STARTED_SUMMARIZER="true"  # Mark for cleanup trap
            log_info "Summarizer started (PID: $pid)"
            return 0
        fi
        sleep 0.5
        attempts=$((attempts + 1))
    done

    # Process may have died - check if still running
    if kill -0 "$pid" 2>/dev/null; then
        log_error "Summarizer started but health check failed"
    else
        log_error "Summarizer failed to start - check $DATA_PATH/summarizer.log"
    fi
    return 1
}

stop_summarizer() {
    if is_summarizer_running; then
        local pid
        pid=$(cat "$SUMMARIZER_PID_FILE")
        log_info "Stopping summarizer (PID: $pid)..."
        kill "$pid" 2>/dev/null || true
        rm -f "$SUMMARIZER_PID_FILE"
        log_info "Summarizer stopped"
    fi
}

start_daemon() {
    if is_daemon_running; then
        log_info "Daemon is already running"
        return 0
    fi

    # Clean up any stopped container with the same name
    docker rm "$DAEMON_CONTAINER_NAME" 2>/dev/null || true

    log_info "Starting Cortex daemon..."

    build_docker_volumes
    build_docker_env

    docker run -d \
        --name "$DAEMON_CONTAINER_NAME" \
        --restart unless-stopped \
        -p "${CORTEX_PORT}:8080" \
        "${DOCKER_VOLUMES[@]}" \
        -e "CORTEX_HTTP_PORT=8080" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" daemon >&2

    if wait_for_daemon; then
        log_info "Daemon started on port $CORTEX_PORT"

        # Start summarizer if using claude-cli
        start_summarizer

        return 0
    else
        log_error "Daemon failed to start"
        docker logs "$DAEMON_CONTAINER_NAME" >&2
        return 1
    fi
}

stop_daemon() {
    # Stop summarizer first
    stop_summarizer

    if is_daemon_running; then
        log_info "Stopping Cortex daemon..."
        docker stop "$DAEMON_CONTAINER_NAME" >&2
        docker rm "$DAEMON_CONTAINER_NAME" >&2
        log_info "Daemon stopped"
    else
        log_info "Daemon is not running"
    fi
}

daemon_status() {
    if is_daemon_running; then
        echo "Daemon is running"
        docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo ""
        echo "Build info:"
        curl -s "http://localhost:${CORTEX_PORT}/info" 2>/dev/null || echo "Failed to reach daemon"
        echo ""
        echo ""
        echo "Local HEAD: $(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
    else
        echo "Daemon is not running"
        exit 1
    fi
}

daemon_logs() {
    if is_daemon_running; then
        docker logs -f "$DAEMON_CONTAINER_NAME"
    else
        # Show logs from stopped container if it exists
        docker logs "$DAEMON_CONTAINER_NAME" 2>/dev/null || echo "No logs available"
    fi
}

# --- Configuration Commands ---

init_config() {
    echo "Cortex Setup"
    echo "============"
    echo ""
    echo "This will create ~/.cortex/config.yaml"
    echo ""

    # Ensure data directory exists
    mkdir -p "$DATA_PATH"

    # Collect code paths
    echo "Enter the directories containing code you want to index."
    echo "You can enter multiple paths, one per line."
    echo "Press Enter on an empty line when done."
    echo ""
    echo "Examples:"
    echo "  ~/Projects"
    echo "  ~/Work"
    echo "  /path/to/specific/repo"
    echo ""

    local paths=()
    while true; do
        read -r -p "Code path (or Enter to finish): " path
        if [ -z "$path" ]; then
            break
        fi
        # Expand ~ to $HOME for validation
        local expanded_path="${path/#\~/$HOME}"
        if [ -d "$expanded_path" ]; then
            paths+=("$path")
            echo "  Added: $path"
        else
            echo "  Warning: Directory does not exist: $path"
            read -r -p "  Add anyway? [y/N]: " confirm
            if [[ "$confirm" =~ ^[Yy] ]]; then
                paths+=("$path")
                echo "  Added: $path"
            fi
        fi
    done

    if [ ${#paths[@]} -eq 0 ]; then
        echo ""
        echo "Warning: No code paths configured. You can add them later with:"
        echo "  cortex config edit"
        echo ""
    fi

    # Debug mode
    echo ""
    read -r -p "Enable debug logging? [y/N]: " debug_input
    local debug="false"
    if [[ "$debug_input" =~ ^[Yy] ]]; then
        debug="true"
    fi

    # Port
    echo ""
    echo "Server port (for MCP and HTTP API):"
    read -r -p "Port [8000]: " port_input
    local port="${port_input:-8000}"

    # Validate port is a number and in valid range
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo "Invalid port, using 8000"
        port="8000"
    fi

    # Build code_paths YAML
    local paths_yaml=""
    if [ ${#paths[@]} -gt 0 ]; then
        paths_yaml=$(printf '%s\n' "${paths[@]}" | python3 -c "
import sys
paths = [line.strip() for line in sys.stdin if line.strip()]
for p in paths:
    print(f'  - {p}')
")
    else
        paths_yaml="  # - ~/Projects"
    fi

    # Write config file
    cat > "$CONFIG_FILE" << EOF
# Cortex Configuration
# Edit this file to customize Cortex behavior.

# Daemon Settings
# Directories containing code to index (mounted into Docker)
code_paths:
$paths_yaml

# Server port (for MCP and HTTP API)
port: $port

# Enable debug logging
debug: $debug

# LLM Provider Configuration
# Used for session summarization and code header generation
llm:
  # Primary provider: anthropic, ollama, openrouter, claude-cli
  primary_provider: "claude-cli"

  # Fallback chain (tried in order if primary fails)
  fallback_chain:
    - "anthropic"
    - "ollama"

# Auto-Capture Configuration
autocapture:
  # Enable auto-capture on session end
  enabled: true

  # Significance thresholds (session is significant if ANY threshold is met)
  significance:
    min_tokens: 5000
    min_file_edits: 1
    min_tool_calls: 3

# Runtime Settings
runtime:
  min_score: 0.5
  verbose: false
  recency_boost: true
  recency_half_life_days: 30.0
EOF

    echo ""
    echo "Config saved to: $CONFIG_FILE"
    echo ""
    cat "$CONFIG_FILE"
    echo ""

    # Check if daemon needs restart
    if is_daemon_running; then
        echo ""
        echo "Note: Daemon is running. Restart it to apply changes:"
        echo "  cortex daemon restart"
    fi

    # Install hooks for auto-capture
    echo ""
    echo "Installing auto-capture hooks..."
    echo ""
    hooks_install
    echo ""

    echo "Next steps:"
    echo "  1. Start the Cortex daemon:"
    echo "     cortex daemon start"
    echo ""
    echo "  2. Add Cortex to Claude Code:"
    echo "     claude mcp add cortex cortex --scope user"
    echo ""
    echo "  3. Restart Claude Code to load the MCP server"
    echo ""
}

show_config() {
    echo "Cortex Configuration"
    echo "===================="
    echo ""
    echo "Config file: $CONFIG_FILE"
    echo ""

    if [ -f "$CONFIG_FILE" ]; then
        echo "Current config:"
        cat "$CONFIG_FILE"
    else
        echo "No config file found."
        echo ""
        echo "Run 'cortex init' to create one."
    fi

    echo ""
    echo "Active configuration (after env var overrides):"
    echo "  code_paths: ${CODE_PATHS:-<not set>}"
    echo "  debug: ${CORTEX_DEBUG:-<not set>}"
    echo "  port: $CORTEX_PORT"
    echo ""

    # Show any env var overrides
    if [ -n "$ENV_OVERRIDE_CODE_PATHS" ]; then
        echo "Note: CORTEX_CODE_PATHS env var is overriding config.yaml"
    fi
    if [ -n "$ENV_OVERRIDE_DEBUG" ]; then
        echo "Note: CORTEX_DEBUG env var is overriding config.yaml"
    fi
    if [ -n "$ENV_OVERRIDE_PORT" ]; then
        echo "Note: CORTEX_PORT env var is overriding config.yaml"
    fi
}

edit_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "No config file found. Creating default..."
        mkdir -p "$DATA_PATH"
        # Use config parser script to create default config
        python3 "$CORTEX_SRC_DIR/scripts/config_parser.py" create-default "$CONFIG_FILE"
    fi

    local editor="${EDITOR:-${VISUAL:-vi}}"
    echo "Opening $CONFIG_FILE with $editor..."
    "$editor" "$CONFIG_FILE"

    # Validate YAML after editing
    if python3 -c "import yaml; yaml.safe_load(open('$CONFIG_FILE'))" 2>/dev/null; then
        echo "Config file is valid YAML."
        if is_daemon_running; then
            echo ""
            echo "Note: Restart daemon to apply changes:"
            echo "  cortex daemon restart"
        fi
    else
        echo "Warning: Config file contains invalid YAML!"
        echo "Please fix the syntax errors."
    fi
}

run_bridge() {
    # Ensure daemon is running
    if ! is_daemon_running; then
        build_image_if_needed
        start_daemon
    fi

    # Build env vars for bridge
    build_docker_env

    # Run bridge in foreground, connecting to daemon
    exec docker run -i --rm \
        --network host \
        -e "CORTEX_DAEMON_URL=http://localhost:${CORTEX_PORT}" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" bridge
}

# --- Update Command ---

do_update() {
    local force_build=false

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --build|-b)
                force_build=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    echo "Cortex Update"
    echo "============="
    echo ""

    # Step 1: Check current version
    echo "Checking versions..."
    local current_commit
    local local_commit

    current_commit=$(curl -sf "http://localhost:${CORTEX_PORT}/info" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(data.get('git_commit', 'unknown')[:7])
" 2>/dev/null || echo "unknown")

    local_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")

    echo "  Running: $current_commit"
    echo "  Local:   $local_commit"
    echo ""

    if [ "$current_commit" = "$local_commit" ] && [ "$current_commit" != "unknown" ]; then
        echo "Already up to date."
        return 0
    fi

    # Step 2: Backup database
    echo "Creating backup..."
    if is_daemon_running; then
        local backup_result
        backup_result=$(curl -sf -X POST "http://localhost:${CORTEX_PORT}/admin/backup" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local backup_path
            backup_path=$(echo "$backup_result" | python3 -c "import json,sys; print(json.load(sys.stdin).get('backup_path',''))" 2>/dev/null)
            if [ -n "$backup_path" ]; then
                echo "  Backup created: $backup_path"
            fi
        else
            echo "  Warning: Could not create backup via API, creating manual backup..."
            if [ -d "$DATA_PATH/db" ]; then
                local backup_name="backup_update_$(date +%Y%m%d_%H%M%S)"
                mkdir -p "$DATA_PATH/backups"
                cp -r "$DATA_PATH/db" "$DATA_PATH/backups/$backup_name"
                echo "  Manual backup created: $DATA_PATH/backups/$backup_name"
            fi
        fi
    else
        # Manual backup if daemon not running
        if [ -d "$DATA_PATH/db" ]; then
            local backup_name="backup_update_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$DATA_PATH/backups"
            cp -r "$DATA_PATH/db" "$DATA_PATH/backups/$backup_name"
            echo "  Manual backup created: $DATA_PATH/backups/$backup_name"
        fi
    fi
    echo ""

    # Step 3: Pull latest code (if git repo)
    if [ -d "$CORTEX_SRC_DIR/.git" ]; then
        echo "Pulling latest code..."
        if git -C "$CORTEX_SRC_DIR" pull --ff-only 2>&1; then
            echo "  Code updated"
        else
            echo "  Warning: git pull failed (may have local changes), continuing with local code"
        fi
        echo ""
    fi

    # Step 4: Stop daemon
    echo "Stopping daemon..."
    stop_daemon
    echo ""

    # Step 5: Pull or rebuild image
    echo "Updating image..."
    if [ "$force_build" = true ]; then
        echo "  Building locally (--build flag)..."
        build_image
    elif pull_image; then
        echo "  Image pulled from GHCR"
    else
        echo "  Pull failed, building locally..."
        build_image
    fi
    echo ""

    # Step 6: Start daemon (migrations run automatically)
    echo "Starting daemon..."
    start_daemon
    echo ""

    # Step 7: Verify
    if is_daemon_running; then
        local new_commit
        new_commit=$(curl -sf "http://localhost:${CORTEX_PORT}/info" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(data.get('git_commit', 'unknown')[:7])
" 2>/dev/null || echo "unknown")

        echo "Update complete!"
        echo "  Now running: $new_commit"

        # Check migration status
        local migration_status
        migration_status=$(curl -sf "http://localhost:${CORTEX_PORT}/migrations/status" 2>/dev/null)
        if [ $? -eq 0 ]; then
            echo "$migration_status" | python3 -c "
import json, sys
data = json.load(sys.stdin)
version = data.get('current_version', 'unknown')
print(f'  Schema version: v{version}')
" 2>/dev/null
        fi

        # Step 8: Update hooks
        echo ""
        echo "Updating hooks..."
        hooks_repair >/dev/null 2>&1 && echo "  Hooks updated" || echo "  Hook update skipped (run 'cortex hooks repair' if needed)"
    else
        log_error "Daemon failed to start after update"
        echo ""
        echo "To restore from backup:"
        echo "  1. Find your backup in $DATA_PATH/backups/"
        echo "  2. Run: rm -rf $DATA_PATH/db && cp -r $DATA_PATH/backups/<backup_name> $DATA_PATH/db"
        echo "  3. Run: cortex daemon start"
        return 1
    fi
}

# --- Hooks Command ---

hooks_install() {
    local force_flag=""
    if [ "${1:-}" = "--force" ] || [ "${1:-}" = "-f" ]; then
        force_flag="--force"
    fi

    echo "Installing Cortex hooks..."
    echo ""

    python3 "$CORTEX_SRC_DIR/scripts/hooks_manager.py" --source-dir "$CORTEX_SRC_DIR" install $force_flag
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hook installation complete."
        echo ""
        echo "Auto-capture is now enabled. Sessions will be automatically"
        echo "saved to Cortex when you exit Claude Code."
    else
        echo "Hook installation had issues. Run 'cortex hooks status' for details."
    fi

    return $result
}

hooks_status() {
    echo "Cortex Hook Status"
    echo "=================="
    echo ""

    python3 "$CORTEX_SRC_DIR/scripts/hooks_manager.py" --source-dir "$CORTEX_SRC_DIR" status
}

hooks_repair() {
    echo "Repairing Cortex hooks..."
    echo ""

    python3 "$CORTEX_SRC_DIR/scripts/hooks_manager.py" --source-dir "$CORTEX_SRC_DIR" repair
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hook repair complete."
    else
        echo "Hook repair failed."
    fi

    return $result
}

hooks_uninstall() {
    echo "Uninstalling Cortex hooks..."
    echo ""

    python3 "$CORTEX_SRC_DIR/scripts/hooks_manager.py" --source-dir "$CORTEX_SRC_DIR" uninstall
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hooks uninstalled. Auto-capture is now disabled."
    fi

    return $result
}

# --- Doctor Command ---

doctor_essential() {
    echo "Cortex Doctor (Essential Checks)"
    echo "================================="
    echo ""

    local all_passed=true

    # Check 1: Docker daemon
    echo -n "Docker daemon: "
    if docker info >/dev/null 2>&1; then
        echo "OK"
    else
        echo "FAIL - Docker is not running"
        all_passed=false
    fi

    # Check 2: Cortex container exists
    echo -n "Cortex container: "
    if docker ps -a --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${DAEMON_CONTAINER_NAME}$"; then
        if is_daemon_running; then
            echo "OK (running)"
        else
            echo "WARN - Container exists but not running"
        fi
    else
        echo "MISSING - Run 'cortex daemon start'"
        all_passed=false
    fi

    # Check 3: Port availability
    echo -n "Port $CORTEX_PORT: "
    local port_user
    port_user=$(lsof -i :$CORTEX_PORT -t 2>/dev/null | head -1)
    if [ -z "$port_user" ]; then
        if is_daemon_running; then
            echo "WARN - Daemon running but port not bound"
        else
            echo "AVAILABLE"
        fi
    else
        local port_process
        port_process=$(ps -p "$port_user" -o comm= 2>/dev/null || echo "unknown")
        if docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Ports}}' 2>/dev/null | grep -q "$CORTEX_PORT"; then
            echo "OK (used by cortex)"
        else
            echo "WARN - In use by $port_process (PID $port_user)"
        fi
    fi

    # Check 4: Health endpoint
    echo -n "Health endpoint: "
    if curl -sf "http://localhost:${CORTEX_PORT}/health" >/dev/null 2>&1; then
        echo "OK"
    else
        if is_daemon_running; then
            echo "FAIL - Daemon running but /health unreachable"
            all_passed=false
        else
            echo "SKIP - Daemon not running"
        fi
    fi

    echo ""
    if [ "$all_passed" = true ]; then
        echo "All essential checks passed."
        return 0
    else
        echo "Some checks failed. Run 'cortex doctor --verbose' for more details."
        return 1
    fi
}

doctor_comprehensive() {
    echo "Cortex Doctor (Comprehensive)"
    echo "=============================="
    echo ""

    # Run essential checks first
    doctor_essential
    local essential_status=$?
    echo ""

    echo "Extended Checks"
    echo "---------------"

    # Check 5: ChromaDB collection stats
    echo -n "ChromaDB collection: "
    local stats
    stats=$(curl -sf "http://localhost:${CORTEX_PORT}/browse/stats" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local doc_count
        doc_count=$(echo "$stats" | python3 -c "import json,sys; print(json.load(sys.stdin).get('total_documents', 0))" 2>/dev/null)
        echo "OK ($doc_count documents)"
    else
        echo "WARN - Cannot fetch stats"
    fi

    # Check 6: Index/build info
    echo -n "Build info: "
    local info
    info=$(curl -sf "http://localhost:${CORTEX_PORT}/info" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "OK"
        echo "$info" | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(f\"  Commit: {data.get('git_commit', 'unknown')[:7]}\")
print(f\"  Build: {data.get('build_time', 'unknown')}\")
" 2>/dev/null
    else
        echo "WARN - Cannot fetch info"
    fi

    # Check 7: Config file
    echo -n "Config file: "
    if [ -f "$CONFIG_FILE" ]; then
        if python3 -c "import yaml; yaml.safe_load(open('$CONFIG_FILE'))" 2>/dev/null; then
            echo "OK ($CONFIG_FILE)"
        else
            echo "INVALID - YAML parse error"
        fi
    else
        echo "MISSING - Run 'cortex init'"
    fi

    # Check 8: Data directory
    echo -n "Data directory: "
    if [ -d "$DATA_PATH" ]; then
        local data_size
        data_size=$(du -sh "$DATA_PATH" 2>/dev/null | cut -f1)
        echo "OK ($DATA_PATH, $data_size)"
    else
        echo "MISSING"
    fi

    # Check 9: Disk space
    echo -n "Disk space: "
    local available_mb
    available_mb=$(df -m "$DATA_PATH" 2>/dev/null | tail -1 | awk '{print $4}')
    if [ -n "$available_mb" ] && [ "$available_mb" -gt 500 ]; then
        echo "OK (${available_mb}MB available)"
    elif [ -n "$available_mb" ]; then
        echo "WARN - Low disk space (${available_mb}MB)"
    else
        echo "UNKNOWN"
    fi

    # Check 10: Schema version
    echo -n "Schema version: "
    local migration_status
    migration_status=$(curl -sf "http://localhost:${CORTEX_PORT}/migrations/status" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "$migration_status" | python3 -c "
import json, sys
data = json.load(sys.stdin)
current = data.get('current_version', 0)
target = data.get('target_version', 0)
if current == target:
    print(f'OK (v{current})')
else:
    print(f'NEEDS MIGRATION (v{current} -> v{target})')
" 2>/dev/null
    else
        echo "UNKNOWN"
    fi

    # Check 11: Local vs running version
    echo -n "Version sync: "
    local running_commit
    local local_commit
    running_commit=$(curl -sf "http://localhost:${CORTEX_PORT}/info" 2>/dev/null | python3 -c "import json,sys; print(json.load(sys.stdin).get('git_commit','unknown')[:7])" 2>/dev/null || echo "unknown")
    local_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    if [ "$running_commit" = "$local_commit" ]; then
        echo "OK (both at $local_commit)"
    elif [ "$running_commit" = "unknown" ] || [ "$local_commit" = "unknown" ]; then
        echo "UNKNOWN"
    else
        echo "OUT OF SYNC (running: $running_commit, local: $local_commit)"
        echo "  Run 'cortex update' to sync"
    fi

    # Check 12: Available updates (GHCR)
    echo -n "Updates available: "
    local version_check
    version_check=$(curl -sf "http://localhost:${CORTEX_PORT}/version/check" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "$version_check" | python3 "$CORTEX_SRC_DIR/scripts/cli_helpers.py" format-version-check 2>/dev/null || echo "UNKNOWN"
    else
        echo "UNKNOWN (daemon not responding)"
    fi

    # Check 13: Auto-capture hooks
    echo -n "Auto-capture hooks: "
    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
try:
    from src.integrations.hooks import get_hook_status
    status = get_hook_status()
    if status.claude_code_installed:
        print('OK (Claude Code hook installed)')
    elif status.claude_code_available:
        print('NOT INSTALLED')
        print('  Run \"cortex hooks install\" to enable auto-capture')
    else:
        print('SKIP (Claude CLI not found)')
except Exception as e:
    print(f'ERROR ({e})')
" 2>/dev/null || echo "UNKNOWN"

    # Check 14: LLM Provider
    echo ""
    echo "LLM Provider"
    echo "------------"
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"
    echo "Configured provider: $llm_provider"

    case "$llm_provider" in
        claude-cli)
            # Check if claude CLI is available on host
            echo -n "  Claude CLI: "
            if command -v claude &>/dev/null; then
                echo "OK (found in PATH)"
            else
                echo "NOT FOUND"
                echo "    Install with: npm install -g @anthropic-ai/claude-code"
            fi

            # Check if summarizer proxy is running (needed for Docker mode)
            echo -n "  Summarizer proxy: "
            if is_summarizer_running; then
                local pid
                pid=$(cat "$SUMMARIZER_PID_FILE")
                echo "OK (PID: $pid)"
            else
                echo "NOT RUNNING"
                echo "    Will be started when daemon starts"
            fi

            # Check if summarizer is actually reachable
            echo -n "  Summarizer reachable: "
            if curl -sf "http://localhost:$SUMMARIZER_PORT/health" >/dev/null 2>&1; then
                echo "OK (port $SUMMARIZER_PORT)"
            else
                if is_summarizer_running; then
                    echo "FAIL - Process running but /health unreachable"
                else
                    echo "SKIP - Not running"
                fi
            fi
            ;;
        anthropic)
            echo -n "  ANTHROPIC_API_KEY: "
            if [ -n "$ANTHROPIC_API_KEY" ]; then
                echo "OK (set)"
            else
                echo "NOT SET"
                echo "    Export ANTHROPIC_API_KEY to enable"
            fi
            ;;
        openrouter)
            echo -n "  OPENROUTER_API_KEY: "
            if [ -n "$OPENROUTER_API_KEY" ]; then
                echo "OK (set)"
            else
                echo "NOT SET"
                echo "    Export OPENROUTER_API_KEY to enable"
            fi
            ;;
        ollama)
            echo -n "  Ollama server: "
            if curl -sf "http://localhost:11434/api/version" >/dev/null 2>&1; then
                local ollama_version
                ollama_version=$(curl -sf "http://localhost:11434/api/version" | python3 -c "import json,sys; print(json.load(sys.stdin).get('version','unknown'))" 2>/dev/null)
                echo "OK (v$ollama_version)"
            else
                echo "NOT REACHABLE"
                echo "    Start Ollama or check if it's running on localhost:11434"
            fi
            ;;
        none)
            echo "  No LLM provider configured"
            echo "  Auto-capture summarization will be disabled"
            echo "  Set llm.primary_provider in ~/.cortex/config.yaml"
            ;;
        *)
            echo "  Unknown provider: $llm_provider"
            ;;
    esac

    echo ""
    return $essential_status
}

# --- CLI Commands (bypass LLM) ---

cli_search() {
    local query="$*"
    if [ -z "$query" ]; then
        echo "Usage: cortex search <query>" >&2
        echo "Example: cortex search authentication flow" >&2
        exit 1
    fi

    if ! is_daemon_running; then
        echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
        exit 1
    fi

    # URL-encode the query using helper script (avoids injection issues)
    local encoded_query
    encoded_query=$(python3 "$CORTEX_SRC_DIR/scripts/cli_helpers.py" url-encode "$query")

    # Call the HTTP API
    local response
    response=$(curl -sf "http://localhost:${CORTEX_PORT}/search?q=${encoded_query}&limit=5")

    if [ $? -ne 0 ]; then
        echo "Error: Search failed. Is the daemon running?" >&2
        exit 1
    fi

    # Pretty-print results using helper script
    echo "$response" | python3 "$CORTEX_SRC_DIR/scripts/cli_helpers.py" format-search
}

cli_save() {
    # Parse options
    local title=""
    local project="notes"
    local tags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--title)
                title="$2"
                shift 2
                ;;
            -p|--project)
                project="$2"
                shift 2
                ;;
            --tags)
                tags="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Unknown option: $1" >&2
                echo "Usage: cortex save [-t title] [-p project] [--tags tag1,tag2] <content>" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done

    local content="$*"
    if [ -z "$content" ]; then
        echo "Usage: cortex save [-t title] [-p project] [--tags tag1,tag2] <content>" >&2
        echo "Example: cortex save -t 'Auth Decision' 'We chose JWT for auth because...'" >&2
        exit 1
    fi

    if ! is_daemon_running; then
        echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
        exit 1
    fi

    # Build JSON payload
    local json_payload
    json_payload=$(python3 -c "
import json
payload = {
    'content': '''$content''',
    'project': '$project'
}
if '$title':
    payload['title'] = '$title'
if '$tags':
    payload['tags'] = '$tags'.split(',')
print(json.dumps(payload))
")

    # Call the HTTP API
    local response
    response=$(curl -sf -X POST \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        "http://localhost:${CORTEX_PORT}/note")

    if [ $? -ne 0 ]; then
        echo "Error: Save failed. Is the daemon running?" >&2
        exit 1
    fi

    # Show result
    echo "$response" | python3 -c "
import json
import sys
data = json.load(sys.stdin)
if data.get('status') == 'success':
    title = data.get('title', '(untitled)')
    doc_id = data.get('id', 'unknown')
    print(f'Saved: {title}')
    print(f'ID: {doc_id}')
else:
    print('Save failed', file=sys.stderr)
    sys.exit(1)
"
}

cli_status() {
    if ! is_daemon_running; then
        echo "Daemon: not running"
        echo "Run 'cortex daemon start' to start"
        exit 1
    fi

    # Check health and get build info
    local health
    local info
    health=$(curl -sf "http://localhost:${CORTEX_PORT}/health" 2>/dev/null)
    info=$(curl -sf "http://localhost:${CORTEX_PORT}/info" 2>/dev/null)

    if [ $? -ne 0 ]; then
        echo "Error: Could not reach daemon" >&2
        exit 1
    fi

    echo "Cortex Status"
    echo "============="
    echo ""
    echo "Daemon: running"
    echo ""

    # Parse and display info
    echo "$info" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(f\"Build Info:\")
    print(f\"  Version:   {data.get('version', 'unknown')}\")
    print(f\"  Commit:    {data.get('git_commit', 'unknown')}\")
    print(f\"  Built:     {data.get('build_time', 'unknown')}\")
    print(f\"  Started:   {data.get('startup_time', 'unknown')}\")
except:
    print('Could not parse build info')
"
    echo ""
    echo "For full session context, use the MCP tool: orient_session"
}

cli_initiative() {
    # Initiative management is available via MCP tools
    # This CLI command provides guidance on using those tools

    echo "Initiative Management"
    echo "====================="
    echo ""
    echo "Initiatives are managed via the MCP tool: manage_initiative"
    echo ""
    echo "In Claude Code, use these commands:"
    echo ""
    echo "  Create:   manage_initiative(action='create', repository='<repo>', name='<name>', goal='<goal>')"
    echo "  List:     manage_initiative(action='list', repository='<repo>')"
    echo "  Focus:    manage_initiative(action='focus', repository='<repo>', initiative='<name>')"
    echo "  Complete: manage_initiative(action='complete', repository='<repo>', initiative='<name>', summary='<summary>')"
    echo ""
    echo "Or use the orient_session tool to see your current active initiative."
}

cli_ingest() {
    local task_id=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status)
                task_id="${2:-}"
                shift
                if [ -n "$task_id" ] && [[ "$task_id" != --* ]]; then
                    shift
                else
                    task_id=""
                fi
                # Show status
                if ! is_daemon_running; then
                    echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
                    exit 1
                fi

                echo "Ingestion Status"
                echo "================"
                echo ""
                if [ -n "$task_id" ]; then
                    curl -sf "http://localhost:${CORTEX_PORT}/ingest-status/$task_id" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(f\"Task ID: {data.get('task_id', 'unknown')}\")
    print(f\"Repository: {data.get('repository', 'unknown')}\")
    print(f\"Status: {data.get('status', 'unknown')}\")
    progress = data.get('progress', {})
    if progress:
        print(f\"Progress: {progress.get('files_processed', 0)}/{progress.get('files_total', 0)} files ({progress.get('percent', 0)}%)\")
except:
    print('Could not parse task status')
"
                else
                    curl -sf "http://localhost:${CORTEX_PORT}/ingest-status" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    tasks = data.get('tasks', [])
    if not tasks:
        print('No recent ingestion tasks.')
    else:
        for t in tasks[:5]:
            print(f\"{t.get('status', '?'):10} {t.get('repository', 'unknown'):20} ({t.get('progress', {}).get('percent', 0)}%)\")
except:
    print('Could not parse ingestion status')
"
                fi
                return 0
                ;;
            *)
                # Unrecognized argument
                shift
                ;;
        esac
    done

    # No --status flag - show help for starting ingestion
    echo "Codebase Ingestion"
    echo "=================="
    echo ""
    echo "To index a codebase, use the MCP tool: ingest_codebase"
    echo ""
    echo "In Claude Code:"
    echo "  ingest_codebase(path='/path/to/repo')"
    echo "  ingest_codebase(path='/path/to/repo', force_full=True)  # Full re-index"
    echo ""
    echo "Check status:"
    echo "  cortex ingest --status           # List recent tasks"
    echo "  cortex ingest --status <task_id> # Check specific task"
}

cli_backup() {
    local action="${1:-list}"
    shift || true

    if ! is_daemon_running; then
        echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
        exit 1
    fi

    case "$action" in
        create)
            local label="${1:-manual}"
            local response
            # Label is passed as query parameter
            response=$(curl -sf -X POST "http://localhost:${CORTEX_PORT}/admin/backup?label=$label")

            if [ $? -ne 0 ]; then
                echo "Error: Backup failed" >&2
                exit 1
            fi

            echo "$response" | python3 -c "
import json, sys
data = json.load(sys.stdin)
status = data.get('status', 'unknown')
if status == 'success':
    path = data.get('backup_path', 'unknown')
    print(f'Backup created: {path}')
else:
    error = data.get('error', 'Unknown error')
    print(f'Backup failed: {error}')
"
            ;;
        list)
            local response
            response=$(curl -sf "http://localhost:${CORTEX_PORT}/admin/backups" 2>/dev/null)
            if [ $? -ne 0 ]; then
                echo "Error: Could not fetch backups" >&2
                exit 1
            fi
            echo "$response" | python3 "$CORTEX_SRC_DIR/scripts/cli_helpers.py" format-backups
            ;;
        *)
            echo "Usage: cortex backup {create|list}" >&2
            echo "" >&2
            echo "Commands:" >&2
            echo "  create [label]    Create a new backup" >&2
            echo "  list              List all backups" >&2
            exit 1
            ;;
    esac
}

# --- Help Command ---

show_help() {
    cat <<'EOF'
Cortex - AI-powered codebase memory for Claude Code

USAGE:
    cortex [COMMAND]

COMMANDS:
    (default)           Start MCP bridge (auto-starts daemon if needed)
    status              Show session context (index status, active initiative)
    search <query>      Search memory directly (bypasses LLM)
    save [opts] <text>  Save a note directly (bypasses LLM)
                        Options: -t <title>, -p <project>, --tags <a,b>
    initiative <action> Manage initiatives (create, list, focus, complete)
    ingest [path]       Index a codebase into memory (--status to check progress)
    backup <action>     Manage backups (create, list)
    update [--build]    Update Cortex (pull image from GHCR, migrate, restart)
                        Use --build to force local image build
    doctor              Check system health (add --verbose for full check)
    init                Interactive setup, creates ~/.cortex/config.yaml
    config              Show current configuration
    config edit         Open config.yaml in $EDITOR
    hooks install       Install auto-capture hooks (add -f to force reinstall)
    hooks status        Show hook installation status
    hooks repair        Reinstall hooks from latest source
    hooks uninstall     Remove hooks and disable auto-capture
    daemon start        Start the daemon container
    daemon stop         Stop the daemon container
    daemon restart      Restart the daemon (rebuilds image)
    daemon status       Check daemon status and build info
    daemon logs         View daemon logs (follows output)
    daemon rebuild [-b] Stop, pull/rebuild image, and restart (--build for local)
    stop                Shortcut for 'daemon stop'
    logs                Shortcut for 'daemon logs'
    rebuild             Shortcut for 'daemon rebuild'
    help, --help, -h    Show this help message

CONFIGURATION:
    Configuration is stored at ~/.cortex/config.yaml
    Run 'cortex init' to create this file interactively.

    Config file options:
      code_paths        List of directories to mount (e.g., ["~/Projects"])
      debug             true or false
      port              Server port (default: 8000)
      llm               LLM provider settings for summarization
      autocapture       Auto-capture settings for session memory

ENVIRONMENT VARIABLES (override config.yaml):
    CORTEX_CODE_PATHS       Comma-separated list of code directories
    CORTEX_DEBUG            Enable debug logging (true/false)
    CORTEX_PORT             Server port (default: 8000)
    CORTEX_LLM_PROVIDER     LLM provider: anthropic, claude-cli, ollama, openrouter, none
    ANTHROPIC_API_KEY       Required for llm.primary_provider="anthropic"
    OPENROUTER_API_KEY      Required for llm.primary_provider="openrouter"

QUICK START:
    1. Run 'cortex init' to configure your settings
    2. Start the daemon: cortex daemon start
    3. Add to Claude Code: claude mcp add cortex cortex --scope user
    4. Restart Claude Code to load the MCP server

EXAMPLES:
    cortex init                 # First-time setup
    cortex                      # Start MCP server (normal usage)
    cortex status               # Check session context
    cortex search auth flow     # Quick search from terminal
    cortex save "Use JWT"       # Save a quick note
    cortex save -t "Decision" "We chose Redis for caching"
    cortex initiative list      # List all initiatives
    cortex ingest ~/myproject   # Index a codebase
    cortex backup create        # Create a backup
    cortex daemon status        # Check if daemon is healthy
    cortex daemon logs          # Debug issues
    cortex config edit          # Modify config
    cortex daemon restart       # Apply config changes

For more information, see: https://github.com/anthropics/cortex
EOF
}

# --- Main Command Handling ---

case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    daemon)
        case "${2:-status}" in
            start)
                build_image_if_needed
                start_daemon
                ;;
            stop)
                stop_daemon
                ;;
            restart)
                local force_build=false
                if [ "${3:-}" = "--build" ] || [ "${3:-}" = "-b" ]; then
                    force_build=true
                fi
                stop_daemon
                if [ "$force_build" = true ]; then
                    build_image
                elif ! pull_image; then
                    build_image
                fi
                start_daemon
                ;;
            status)
                daemon_status
                ;;
            logs)
                daemon_logs
                ;;
            rebuild)
                local force_build=false
                if [ "${3:-}" = "--build" ] || [ "${3:-}" = "-b" ]; then
                    force_build=true
                fi
                stop_daemon
                if [ "$force_build" = true ]; then
                    build_image
                elif ! pull_image; then
                    build_image
                fi
                start_daemon
                ;;
            *)
                echo "Usage: cortex daemon {start|stop|restart|status|logs|rebuild}" >&2
                exit 1
                ;;
        esac
        ;;
    init)
        init_config
        ;;
    config)
        case "${2:-}" in
            edit)
                edit_config
                ;;
            ""|show)
                show_config
                ;;
            *)
                echo "Usage: cortex config [show|edit]" >&2
                exit 1
                ;;
        esac
        ;;
    stop)
        stop_daemon
        ;;
    logs)
        daemon_logs
        ;;
    rebuild)
        local force_build=false
        if [ "${2:-}" = "--build" ] || [ "${2:-}" = "-b" ]; then
            force_build=true
        fi
        stop_daemon
        if [ "$force_build" = true ]; then
            build_image
        elif ! pull_image; then
            build_image
        fi
        start_daemon
        ;;
    search)
        shift
        cli_search "$@"
        ;;
    save)
        shift
        cli_save "$@"
        ;;
    status)
        cli_status
        ;;
    initiative)
        shift
        cli_initiative "$@"
        ;;
    ingest)
        shift
        cli_ingest "$@"
        ;;
    backup)
        shift
        cli_backup "$@"
        ;;
    update)
        shift
        do_update "$@"
        ;;
    hooks)
        case "${2:-status}" in
            install)
                hooks_install "${3:-}"
                ;;
            status)
                hooks_status
                ;;
            repair)
                hooks_repair
                ;;
            uninstall)
                hooks_uninstall
                ;;
            *)
                echo "Usage: cortex hooks {install|status|repair|uninstall}" >&2
                echo "" >&2
                echo "Commands:" >&2
                echo "  install    Install hooks for auto-capture (add -f to force reinstall)" >&2
                echo "  status     Show current hook installation status" >&2
                echo "  repair     Reinstall hooks from latest source" >&2
                echo "  uninstall  Remove hooks and disable auto-capture" >&2
                exit 1
                ;;
        esac
        ;;
    doctor)
        if [ "${2:-}" = "--verbose" ] || [ "${2:-}" = "-v" ]; then
            doctor_comprehensive
        else
            doctor_essential
        fi
        ;;
    "")
        # No arguments: run stdio bridge (auto-starts daemon if needed)
        run_bridge
        ;;
    *)
        # Unknown command
        echo "Error: Unknown command '$1'" >&2
        echo "" >&2
        echo "Run 'cortex help' for usage information." >&2
        exit 1
        ;;
esac
