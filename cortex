#!/bin/bash
#
# Cortex MCP Server Wrapper - Singleton Daemon Architecture
#
# Usage:
#   cortex              - Default: auto-start daemon if needed, run bridge
#   cortex init         - Interactive setup, creates ~/.cortex/config.yaml
#   cortex config       - Show current configuration
#   cortex config edit  - Open config.yaml in $EDITOR
#   cortex daemon start - Start the daemon
#   cortex daemon stop  - Stop the daemon
#   cortex daemon restart - Restart the daemon
#   cortex daemon status - Check daemon status
#   cortex daemon logs  - View daemon logs
#
# Configuration:
#   Settings are stored in ~/.cortex/config.yaml
#   Run 'cortex init' to create this file interactively.
#
# Environment variables (override config.yaml):
#   CORTEX_CODE_PATHS    - Comma-separated list of code directories to mount
#   CORTEX_DEBUG         - Enable debug logging (true/false)
#   CORTEX_DAEMON_PORT   - Daemon port (default: 8000)
#   ANTHROPIC_API_KEY    - Required for LLM provider="anthropic"
#

# --- Configuration ---
DAEMON_CONTAINER_NAME="cortex-daemon"
DAEMON_PORT="${CORTEX_DAEMON_PORT:-8000}"
HTTP_PORT="${CORTEX_HTTP_PORT:-8080}"
SUMMARIZER_PORT="${CORTEX_SUMMARIZER_PORT:-8081}"
IMAGE_NAME="cortex"

# Summarizer PID file (for claude-cli LLM provider)
SUMMARIZER_PID_FILE="$HOME/.cortex/summarizer.pid"

# Defaults
DATA_PATH="${CORTEX_DATA_PATH:-$HOME/.cortex}"
CODE_PATHS="${CORTEX_CODE_PATHS:-}"

# Expand ~ in paths
DATA_PATH="${DATA_PATH/#\~/$HOME}"

# --- Find the Cortex source directory ---
get_script_dir() {
    local source="${BASH_SOURCE[0]}"
    while [ -L "$source" ]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

CORTEX_SRC_DIR="$(get_script_dir)"

# Config file location
CONFIG_FILE="$DATA_PATH/config.yaml"

# Config values (loaded from file, can be overridden by env vars)
CONFIG_CODE_PATHS=""
CONFIG_DEBUG=""
CONFIG_HTTP_PORT=""
CONFIG_DAEMON_PORT=""
CONFIG_LLM_PROVIDER=""

# Track env var overrides (for display purposes)
ENV_OVERRIDE_CODE_PATHS=""
ENV_OVERRIDE_DEBUG=""
ENV_OVERRIDE_HTTP_PORT=""
ENV_OVERRIDE_DAEMON_PORT=""

load_config() {
    # Capture original env vars before loading config
    local orig_code_paths="$CODE_PATHS"
    local orig_debug="$CORTEX_DEBUG"
    local orig_http_port="$CORTEX_HTTP_PORT"
    local orig_daemon_port="$CORTEX_DAEMON_PORT"

    # Load config from ~/.cortex/config.yaml if it exists
    if [ -f "$CONFIG_FILE" ]; then
        # Parse YAML using python3 (available on most systems)
        local config
        config=$(python3 -c "
import sys
try:
    import yaml
    with open('$CONFIG_FILE') as f:
        c = yaml.safe_load(f) or {}
except ImportError:
    # Fallback: simple YAML parsing without PyYAML
    c = {}
    with open('$CONFIG_FILE') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if ':' in line and not line.startswith(' ') and not line.startswith('-'):
                key, val = line.split(':', 1)
                key = key.strip()
                val = val.strip()
                if val and not val.startswith('#'):
                    # Remove quotes
                    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):
                        val = val[1:-1]
                    # Boolean
                    if val.lower() == 'true':
                        val = True
                    elif val.lower() == 'false':
                        val = False
                    # Number
                    else:
                        try:
                            val = int(val)
                        except ValueError:
                            pass
                    c[key] = val

# Output as shell-friendly format
paths = c.get('code_paths', [])
if isinstance(paths, list):
    print('CODE_PATHS=' + ','.join(str(p) for p in paths))
print('DEBUG=' + str(c.get('debug', '')).lower())
print('HTTP_PORT=' + str(c.get('http_port', '')))
print('DAEMON_PORT=' + str(c.get('daemon_port', '')))
# Extract nested llm.primary_provider
llm = c.get('llm', {})
if isinstance(llm, dict):
    print('LLM_PROVIDER=' + str(llm.get('primary_provider', '')))
" 2>/dev/null)

        if [ $? -eq 0 ]; then
            # Parse the output
            while IFS='=' read -r key value; do
                case "$key" in
                    CODE_PATHS) CONFIG_CODE_PATHS="$value" ;;
                    DEBUG) CONFIG_DEBUG="$value" ;;
                    HTTP_PORT) CONFIG_HTTP_PORT="$value" ;;
                    DAEMON_PORT) CONFIG_DAEMON_PORT="$value" ;;
                    LLM_PROVIDER) CONFIG_LLM_PROVIDER="$value" ;;
                esac
            done <<< "$config"
        fi
    fi

    # Apply config (env vars override config file)
    if [ -z "$CODE_PATHS" ] && [ -n "$CONFIG_CODE_PATHS" ]; then
        CODE_PATHS="$CONFIG_CODE_PATHS"
    elif [ -n "$orig_code_paths" ] && [ -n "$CONFIG_CODE_PATHS" ]; then
        ENV_OVERRIDE_CODE_PATHS="true"
    fi

    if [ -z "$CORTEX_DEBUG" ] && [ -n "$CONFIG_DEBUG" ]; then
        CORTEX_DEBUG="$CONFIG_DEBUG"
    elif [ -n "$orig_debug" ] && [ -n "$CONFIG_DEBUG" ]; then
        ENV_OVERRIDE_DEBUG="true"
    fi

    # Apply http_port config
    if [ -z "$CORTEX_HTTP_PORT" ] && [ -n "$CONFIG_HTTP_PORT" ]; then
        HTTP_PORT="$CONFIG_HTTP_PORT"
    elif [ -n "$orig_http_port" ] && [ -n "$CONFIG_HTTP_PORT" ]; then
        ENV_OVERRIDE_HTTP_PORT="true"
    fi

    # Apply daemon_port config
    if [ -z "$CORTEX_DAEMON_PORT" ] && [ -n "$CONFIG_DAEMON_PORT" ]; then
        DAEMON_PORT="$CONFIG_DAEMON_PORT"
    elif [ -n "$orig_daemon_port" ] && [ -n "$CONFIG_DAEMON_PORT" ]; then
        ENV_OVERRIDE_DAEMON_PORT="true"
    fi
}

# Load config on script start
load_config

# --- Helper Functions ---

log_info() {
    echo "[cortex] $1" >&2
}

log_error() {
    echo "[cortex] ERROR: $1" >&2
}

build_image() {
    log_info "Building Cortex Docker image..."

    # Capture git commit and build time for version tracking
    local git_commit
    local build_time
    git_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    log_info "Build info: commit=$git_commit, time=$build_time"

    if docker build \
        --build-arg "GIT_COMMIT=$git_commit" \
        --build-arg "BUILD_TIME=$build_time" \
        -t "$IMAGE_NAME" "$CORTEX_SRC_DIR" >&2; then
        log_info "Image built successfully"
    else
        log_error "Failed to build image"
        exit 1
    fi
}

build_image_if_needed() {
    # Build if image doesn't exist or source is newer
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        build_image
    fi
}

is_daemon_running() {
    docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Names}}' 2>/dev/null | grep -q "^${DAEMON_CONTAINER_NAME}$"
}

wait_for_daemon() {
    local max_attempts=30
    local attempt=0
    log_info "Waiting for daemon to be ready..."

    while [ $attempt -lt $max_attempts ]; do
        if curl -sf "http://localhost:${DAEMON_PORT}/health" >/dev/null 2>&1; then
            log_info "Daemon is ready"
            return 0
        fi
        sleep 0.5
        attempt=$((attempt + 1))
    done

    log_error "Daemon failed to start within timeout"
    return 1
}

# Global arrays for docker arguments
DOCKER_VOLUMES=()
DOCKER_ENVS=()

build_docker_volumes() {
    DOCKER_VOLUMES=()

    # Mount data directory (ensure it exists)
    mkdir -p "$DATA_PATH"
    DOCKER_VOLUMES+=("-v" "$DATA_PATH:$DATA_PATH")

    # Mount code paths
    if [ -n "$CODE_PATHS" ]; then
        IFS=',' read -ra PATHS <<< "$CODE_PATHS"
        for path in "${PATHS[@]}"; do
            path="$(echo "$path" | xargs)"
            path="${path/#\~/$HOME}"
            if [ -d "$path" ]; then
                DOCKER_VOLUMES+=("-v" "$path:$path:ro")
            else
                log_info "Warning: Code path does not exist: $path"
            fi
        done
    fi
}

build_docker_env() {
    DOCKER_ENVS=()
    [ -n "$CORTEX_DEBUG" ] && DOCKER_ENVS+=("-e" "CORTEX_DEBUG=$CORTEX_DEBUG")
    [ -n "$ANTHROPIC_API_KEY" ] && DOCKER_ENVS+=("-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
    [ -n "$OPENROUTER_API_KEY" ] && DOCKER_ENVS+=("-e" "OPENROUTER_API_KEY=$OPENROUTER_API_KEY")
    [ -n "$CORTEX_LOG_FILE" ] && DOCKER_ENVS+=("-e" "CORTEX_LOG_FILE=$CORTEX_LOG_FILE")

    # Determine LLM provider: env var overrides config file
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"

    # Pass the LLM provider setting to the daemon
    DOCKER_ENVS+=("-e" "CORTEX_LLM_PROVIDER=$llm_provider")

    # Pass summarizer URL if using claude-cli (host.docker.internal for Mac/Windows)
    if [ "$llm_provider" = "claude-cli" ]; then
        DOCKER_ENVS+=("-e" "CORTEX_SUMMARIZER_URL=http://host.docker.internal:$SUMMARIZER_PORT")
    fi
}

# --- Summarizer Functions (for claude-cli LLM provider) ---

is_summarizer_running() {
    if [ -f "$SUMMARIZER_PID_FILE" ]; then
        local pid
        pid=$(cat "$SUMMARIZER_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

start_summarizer() {
    # Only start if using claude-cli as LLM provider
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"
    if [ "$llm_provider" != "claude-cli" ]; then
        return 0
    fi

    # Check if claude CLI is available
    if ! command -v claude &>/dev/null; then
        log_error "claude-cli is configured as LLM provider but 'claude' CLI not found"
        log_error "Install with: npm install -g @anthropic-ai/claude-code"
        log_error "Or change llm.primary_provider in ~/.cortex/config.yaml"
        return 1
    fi

    if is_summarizer_running; then
        log_info "Summarizer is already running"
        return 0
    fi

    log_info "Starting summarizer proxy on port $SUMMARIZER_PORT..."

    # Ensure data directory exists
    mkdir -p "$DATA_PATH"

    # Start proxy server in background (run from cortex source directory)
    cd "$CORTEX_SRC_DIR"
    nohup python3 -m src.controllers.proxy.server --port "$SUMMARIZER_PORT" \
        > "$DATA_PATH/summarizer.log" 2>&1 &
    local pid=$!
    cd - >/dev/null
    echo "$pid" > "$SUMMARIZER_PID_FILE"

    # Wait briefly and check if it started
    sleep 1
    if is_summarizer_running; then
        log_info "Summarizer started (PID: $pid)"
        return 0
    else
        log_error "Summarizer failed to start"
        rm -f "$SUMMARIZER_PID_FILE"
        return 1
    fi
}

stop_summarizer() {
    if is_summarizer_running; then
        local pid
        pid=$(cat "$SUMMARIZER_PID_FILE")
        log_info "Stopping summarizer (PID: $pid)..."
        kill "$pid" 2>/dev/null || true
        rm -f "$SUMMARIZER_PID_FILE"
        log_info "Summarizer stopped"
    fi
}

start_daemon() {
    if is_daemon_running; then
        log_info "Daemon is already running"
        return 0
    fi

    # Clean up any stopped container with the same name
    docker rm "$DAEMON_CONTAINER_NAME" 2>/dev/null || true

    log_info "Starting Cortex daemon..."

    build_docker_volumes
    build_docker_env

    docker run -d \
        --name "$DAEMON_CONTAINER_NAME" \
        --restart unless-stopped \
        -p "${DAEMON_PORT}:8080" \
        -p "${HTTP_PORT}:8080" \
        "${DOCKER_VOLUMES[@]}" \
        -e "CORTEX_HTTP_PORT=8080" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" daemon >&2

    if wait_for_daemon; then
        log_info "Daemon started on port $DAEMON_PORT"

        # Start summarizer if using claude-cli
        start_summarizer

        return 0
    else
        log_error "Daemon failed to start"
        docker logs "$DAEMON_CONTAINER_NAME" >&2
        return 1
    fi
}

stop_daemon() {
    # Stop summarizer first
    stop_summarizer

    if is_daemon_running; then
        log_info "Stopping Cortex daemon..."
        docker stop "$DAEMON_CONTAINER_NAME" >&2
        docker rm "$DAEMON_CONTAINER_NAME" >&2
        log_info "Daemon stopped"
    else
        log_info "Daemon is not running"
    fi
}

daemon_status() {
    if is_daemon_running; then
        echo "Daemon is running"
        docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo ""
        echo "Build info:"
        curl -s "http://localhost:${DAEMON_PORT}/info" 2>/dev/null || echo "Failed to reach daemon"
        echo ""
        echo ""
        echo "Local HEAD: $(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
    else
        echo "Daemon is not running"
        exit 1
    fi
}

daemon_logs() {
    if is_daemon_running; then
        docker logs -f "$DAEMON_CONTAINER_NAME"
    else
        # Show logs from stopped container if it exists
        docker logs "$DAEMON_CONTAINER_NAME" 2>/dev/null || echo "No logs available"
    fi
}

# --- Configuration Commands ---

init_config() {
    echo "Cortex Setup"
    echo "============"
    echo ""
    echo "This will create ~/.cortex/config.yaml"
    echo ""

    # Ensure data directory exists
    mkdir -p "$DATA_PATH"

    # Collect code paths
    echo "Enter the directories containing code you want to index."
    echo "You can enter multiple paths, one per line."
    echo "Press Enter on an empty line when done."
    echo ""
    echo "Examples:"
    echo "  ~/Projects"
    echo "  ~/Work"
    echo "  /path/to/specific/repo"
    echo ""

    local paths=()
    while true; do
        read -r -p "Code path (or Enter to finish): " path
        if [ -z "$path" ]; then
            break
        fi
        # Expand ~ to $HOME for validation
        local expanded_path="${path/#\~/$HOME}"
        if [ -d "$expanded_path" ]; then
            paths+=("$path")
            echo "  Added: $path"
        else
            echo "  Warning: Directory does not exist: $path"
            read -r -p "  Add anyway? [y/N]: " confirm
            if [[ "$confirm" =~ ^[Yy] ]]; then
                paths+=("$path")
                echo "  Added: $path"
            fi
        fi
    done

    if [ ${#paths[@]} -eq 0 ]; then
        echo ""
        echo "Warning: No code paths configured. You can add them later with:"
        echo "  cortex config edit"
        echo ""
    fi

    # Debug mode
    echo ""
    read -r -p "Enable debug logging? [y/N]: " debug_input
    local debug="false"
    if [[ "$debug_input" =~ ^[Yy] ]]; then
        debug="true"
    fi

    # Daemon port
    echo ""
    echo "Daemon port (for MCP communication):"
    read -r -p "Daemon port [8000]: " daemon_port_input
    local daemon_port="${daemon_port_input:-8000}"

    # Validate port is a number
    if ! [[ "$daemon_port" =~ ^[0-9]+$ ]]; then
        echo "Invalid port, using 8000"
        daemon_port="8000"
    fi

    # HTTP port
    echo ""
    echo "HTTP debug server port (for CLI search and web clipper):"
    read -r -p "HTTP port [8080]: " http_port_input
    local http_port="${http_port_input:-8080}"

    # Validate port is a number
    if ! [[ "$http_port" =~ ^[0-9]+$ ]]; then
        echo "Invalid port, using 8080"
        http_port="8080"
    fi

    # Build code_paths YAML
    local paths_yaml=""
    if [ ${#paths[@]} -gt 0 ]; then
        paths_yaml=$(printf '%s\n' "${paths[@]}" | python3 -c "
import sys
paths = [line.strip() for line in sys.stdin if line.strip()]
for p in paths:
    print(f'  - {p}')
")
    else
        paths_yaml="  # - ~/Projects"
    fi

    # Write config file
    cat > "$CONFIG_FILE" << EOF
# Cortex Configuration
# Edit this file to customize Cortex behavior.

# Daemon Settings
# Directories containing code to index (mounted into Docker)
code_paths:
$paths_yaml

# Daemon port for MCP communication
daemon_port: $daemon_port

# HTTP debug server port (for CLI search, web browser, and auto-capture)
http_port: $http_port

# Enable debug logging
debug: $debug

# LLM Provider Configuration
# Used for session summarization and code header generation
llm:
  # Primary provider: anthropic, ollama, openrouter, claude-cli
  primary_provider: "claude-cli"

  # Fallback chain (tried in order if primary fails)
  fallback_chain:
    - "anthropic"
    - "ollama"

# Auto-Capture Configuration
autocapture:
  # Enable auto-capture on session end
  enabled: true

  # Significance thresholds (session is significant if ANY threshold is met)
  significance:
    min_tokens: 5000
    min_file_edits: 1
    min_tool_calls: 3

# Runtime Settings
runtime:
  min_score: 0.5
  verbose: false
  recency_boost: true
  recency_half_life_days: 30.0
EOF

    echo ""
    echo "Config saved to: $CONFIG_FILE"
    echo ""
    cat "$CONFIG_FILE"
    echo ""

    # Check if daemon needs restart
    if is_daemon_running; then
        echo ""
        echo "Note: Daemon is running. Restart it to apply changes:"
        echo "  cortex daemon restart"
    fi

    # Install hooks for auto-capture
    echo ""
    echo "Installing auto-capture hooks..."
    echo ""
    hooks_install
    echo ""

    echo "Next steps:"
    echo "  1. Start the Cortex daemon:"
    echo "     cortex daemon start"
    echo ""
    echo "  2. Add Cortex to Claude Code:"
    echo "     claude mcp add cortex cortex --scope user"
    echo ""
    echo "  3. Restart Claude Code to load the MCP server"
    echo ""
}

show_config() {
    echo "Cortex Configuration"
    echo "===================="
    echo ""
    echo "Config file: $CONFIG_FILE"
    echo ""

    if [ -f "$CONFIG_FILE" ]; then
        echo "Current config:"
        cat "$CONFIG_FILE"
    else
        echo "No config file found."
        echo ""
        echo "Run 'cortex init' to create one."
    fi

    echo ""
    echo "Active configuration (after env var overrides):"
    echo "  code_paths: ${CODE_PATHS:-<not set>}"
    echo "  debug: ${CORTEX_DEBUG:-<not set>}"
    echo "  daemon_port: $DAEMON_PORT"
    echo "  http_port: $HTTP_PORT"
    echo ""

    # Show any env var overrides
    if [ -n "$ENV_OVERRIDE_CODE_PATHS" ]; then
        echo "Note: CORTEX_CODE_PATHS env var is overriding config.yaml"
    fi
    if [ -n "$ENV_OVERRIDE_DEBUG" ]; then
        echo "Note: CORTEX_DEBUG env var is overriding config.yaml"
    fi
    if [ -n "$ENV_OVERRIDE_DAEMON_PORT" ]; then
        echo "Note: CORTEX_DAEMON_PORT env var is overriding config.yaml"
    fi
    if [ -n "$ENV_OVERRIDE_HTTP_PORT" ]; then
        echo "Note: CORTEX_HTTP_PORT env var is overriding config.yaml"
    fi
}

edit_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "No config file found. Creating default..."
        mkdir -p "$DATA_PATH"
        # Use Python to create the default config
        python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
from src.configs.yaml_config import create_default_config
create_default_config()
"
    fi

    local editor="${EDITOR:-${VISUAL:-vi}}"
    echo "Opening $CONFIG_FILE with $editor..."
    "$editor" "$CONFIG_FILE"

    # Validate YAML after editing
    if python3 -c "import yaml; yaml.safe_load(open('$CONFIG_FILE'))" 2>/dev/null; then
        echo "Config file is valid YAML."
        if is_daemon_running; then
            echo ""
            echo "Note: Restart daemon to apply changes:"
            echo "  cortex daemon restart"
        fi
    else
        echo "Warning: Config file contains invalid YAML!"
        echo "Please fix the syntax errors."
    fi
}

run_bridge() {
    # Ensure daemon is running
    if ! is_daemon_running; then
        build_image_if_needed
        start_daemon
    fi

    # Build env vars for bridge
    build_docker_env

    # Run bridge in foreground, connecting to daemon
    exec docker run -i --rm \
        --network host \
        -e "CORTEX_DAEMON_URL=http://localhost:${DAEMON_PORT}" \
        "${DOCKER_ENVS[@]}" \
        "$IMAGE_NAME" bridge
}

# --- Update Command ---

do_update() {
    echo "Cortex Update"
    echo "============="
    echo ""

    # Step 1: Check current version
    echo "Checking versions..."
    local current_commit
    local local_commit

    current_commit=$(curl -sf "http://localhost:${DAEMON_PORT}/info" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(data.get('git_commit', 'unknown')[:7])
" 2>/dev/null || echo "unknown")

    local_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")

    echo "  Running: $current_commit"
    echo "  Local:   $local_commit"
    echo ""

    if [ "$current_commit" = "$local_commit" ] && [ "$current_commit" != "unknown" ]; then
        echo "Already up to date."
        return 0
    fi

    # Step 2: Backup database
    echo "Creating backup..."
    if is_daemon_running; then
        local backup_result
        backup_result=$(curl -sf -X POST "http://localhost:${DAEMON_PORT}/admin/backup" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local backup_path
            backup_path=$(echo "$backup_result" | python3 -c "import json,sys; print(json.load(sys.stdin).get('backup_path',''))" 2>/dev/null)
            if [ -n "$backup_path" ]; then
                echo "  Backup created: $backup_path"
            fi
        else
            echo "  Warning: Could not create backup via API, creating manual backup..."
            if [ -d "$DATA_PATH/db" ]; then
                local backup_name="backup_update_$(date +%Y%m%d_%H%M%S)"
                mkdir -p "$DATA_PATH/backups"
                cp -r "$DATA_PATH/db" "$DATA_PATH/backups/$backup_name"
                echo "  Manual backup created: $DATA_PATH/backups/$backup_name"
            fi
        fi
    else
        # Manual backup if daemon not running
        if [ -d "$DATA_PATH/db" ]; then
            local backup_name="backup_update_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$DATA_PATH/backups"
            cp -r "$DATA_PATH/db" "$DATA_PATH/backups/$backup_name"
            echo "  Manual backup created: $DATA_PATH/backups/$backup_name"
        fi
    fi
    echo ""

    # Step 3: Pull latest code (if git repo)
    if [ -d "$CORTEX_SRC_DIR/.git" ]; then
        echo "Pulling latest code..."
        if git -C "$CORTEX_SRC_DIR" pull --ff-only 2>&1; then
            echo "  Code updated"
        else
            echo "  Warning: git pull failed (may have local changes), continuing with local code"
        fi
        echo ""
    fi

    # Step 4: Stop daemon
    echo "Stopping daemon..."
    stop_daemon
    echo ""

    # Step 5: Rebuild image
    echo "Rebuilding image..."
    build_image
    echo ""

    # Step 6: Start daemon (migrations run automatically)
    echo "Starting daemon..."
    start_daemon
    echo ""

    # Step 7: Verify
    if is_daemon_running; then
        local new_commit
        new_commit=$(curl -sf "http://localhost:${DAEMON_PORT}/info" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(data.get('git_commit', 'unknown')[:7])
" 2>/dev/null || echo "unknown")

        echo "Update complete!"
        echo "  Now running: $new_commit"

        # Check migration status
        local migration_status
        migration_status=$(curl -sf "http://localhost:${DAEMON_PORT}/migrations/status" 2>/dev/null)
        if [ $? -eq 0 ]; then
            echo "$migration_status" | python3 -c "
import json, sys
data = json.load(sys.stdin)
version = data.get('current_version', 'unknown')
print(f'  Schema version: v{version}')
" 2>/dev/null
        fi

        # Step 8: Update hooks
        echo ""
        echo "Updating hooks..."
        hooks_repair >/dev/null 2>&1 && echo "  Hooks updated" || echo "  Hook update skipped (run 'cortex hooks repair' if needed)"
    else
        log_error "Daemon failed to start after update"
        echo ""
        echo "To restore from backup:"
        echo "  1. Find your backup in $DATA_PATH/backups/"
        echo "  2. Run: rm -rf $DATA_PATH/db && cp -r $DATA_PATH/backups/<backup_name> $DATA_PATH/db"
        echo "  3. Run: cortex daemon start"
        return 1
    fi
}

# --- Hooks Command ---

hooks_install() {
    local force=""
    if [ "${1:-}" = "--force" ] || [ "${1:-}" = "-f" ]; then
        force="force=True"
    fi

    echo "Installing Cortex hooks..."
    echo ""

    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
from pathlib import Path
try:
    from src.install import install_hooks
    success, messages = install_hooks(
        claude_code=True,
        source_dir=Path('$CORTEX_SRC_DIR'),
        $force
    )
    for msg in messages:
        print(f'  {msg}')
    sys.exit(0 if success else 1)
except ImportError as e:
    print(f'Error: Could not load install module: {e}')
    print('Make sure you are running from the Cortex source directory.')
    sys.exit(1)
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
"
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hook installation complete."
        echo ""
        echo "Auto-capture is now enabled. Sessions will be automatically"
        echo "saved to Cortex when you exit Claude Code."
    else
        echo "Hook installation had issues. Run 'cortex hooks status' for details."
    fi

    return $result
}

hooks_status() {
    echo "Cortex Hook Status"
    echo "=================="
    echo ""

    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
try:
    from src.install import get_hook_status

    status = get_hook_status()
    details = status.details.get('claude_code', {})

    # Claude Code status
    print('Claude Code:')
    if status.claude_code_available:
        print('  CLI: installed')
    else:
        print('  CLI: not found')

    # SessionEnd hook
    print('')
    print('  SessionEnd (auto-capture):')
    if status.hook_script_exists:
        script_path = details.get('hook_script_path', '~/.cortex/hooks/claude_session_end.py')
        print(f'    Script: {script_path}')
    else:
        print('    Script: not installed')

    if status.claude_code_installed:
        needs_migration = details.get('needs_migration', False)
        if needs_migration:
            print('    Registered: yes (OLD FORMAT - needs migration)')
        else:
            print('    Registered: yes')
    else:
        print('    Registered: no')

    print('')

    # Overall status
    needs_migration = details.get('needs_migration', False)

    if needs_migration:
        print('Status: Hooks ENABLED but using deprecated format')
        print('')
        print('Run \\'cortex hooks repair\\' to migrate to the new format.')
    elif status.any_installed:
        print('Status: Hooks ENABLED (SessionEnd)')
    elif status.claude_code_available:
        print('Status: Hooks NOT enabled')
        print('')
        print('Run \\'cortex hooks install\\' to enable hooks.')
    else:
        print('Status: Claude Code CLI not found')
        print('')
        print('Install Claude Code first, then run \\'cortex hooks install\\'.')

    if status.errors:
        print('')
        print('Errors:')
        for err in status.errors:
            print(f'  - {err}')

except ImportError as e:
    print(f'Error: Could not load install module: {e}')
    sys.exit(1)
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
"
}

hooks_repair() {
    echo "Repairing Cortex hooks..."
    echo ""

    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
from pathlib import Path
try:
    from src.install import repair_hooks, copy_hook_scripts

    # First, refresh hook scripts from source
    success, msg = copy_hook_scripts(Path('$CORTEX_SRC_DIR'))
    print(f'Script refresh: {msg}')

    # Then reinstall/re-register
    success, messages = repair_hooks()
    for msg in messages:
        print(f'  {msg}')
    sys.exit(0 if success else 1)
except ImportError as e:
    print(f'Error: Could not load install module: {e}')
    sys.exit(1)
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
"
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hook repair complete."
    else
        echo "Hook repair failed."
    fi

    return $result
}

hooks_uninstall() {
    echo "Uninstalling Cortex hooks..."
    echo ""

    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
try:
    from src.install.hooks import uninstall_hooks
    success, messages = uninstall_hooks(claude_code=True)
    for msg in messages:
        print(f'  {msg}')
    sys.exit(0 if success else 1)
except ImportError as e:
    print(f'Error: Could not load install module: {e}')
    sys.exit(1)
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
"
    local result=$?

    echo ""
    if [ $result -eq 0 ]; then
        echo "Hooks uninstalled. Auto-capture is now disabled."
    fi

    return $result
}

# --- Doctor Command ---

doctor_essential() {
    echo "Cortex Doctor (Essential Checks)"
    echo "================================="
    echo ""

    local all_passed=true

    # Check 1: Docker daemon
    echo -n "Docker daemon: "
    if docker info >/dev/null 2>&1; then
        echo "OK"
    else
        echo "FAIL - Docker is not running"
        all_passed=false
    fi

    # Check 2: Cortex container exists
    echo -n "Cortex container: "
    if docker ps -a --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${DAEMON_CONTAINER_NAME}$"; then
        if is_daemon_running; then
            echo "OK (running)"
        else
            echo "WARN - Container exists but not running"
        fi
    else
        echo "MISSING - Run 'cortex daemon start'"
        all_passed=false
    fi

    # Check 3: Port availability
    echo -n "Port $DAEMON_PORT: "
    local port_user
    port_user=$(lsof -i :$DAEMON_PORT -t 2>/dev/null | head -1)
    if [ -z "$port_user" ]; then
        if is_daemon_running; then
            echo "WARN - Daemon running but port not bound"
        else
            echo "AVAILABLE"
        fi
    else
        local port_process
        port_process=$(ps -p "$port_user" -o comm= 2>/dev/null || echo "unknown")
        if docker ps --filter "name=^${DAEMON_CONTAINER_NAME}$" --format '{{.Ports}}' 2>/dev/null | grep -q "$DAEMON_PORT"; then
            echo "OK (used by cortex)"
        else
            echo "WARN - In use by $port_process (PID $port_user)"
        fi
    fi

    # Check 4: Health endpoint
    echo -n "Health endpoint: "
    if curl -sf "http://localhost:${DAEMON_PORT}/health" >/dev/null 2>&1; then
        echo "OK"
    else
        if is_daemon_running; then
            echo "FAIL - Daemon running but /health unreachable"
            all_passed=false
        else
            echo "SKIP - Daemon not running"
        fi
    fi

    echo ""
    if [ "$all_passed" = true ]; then
        echo "All essential checks passed."
        return 0
    else
        echo "Some checks failed. Run 'cortex doctor --verbose' for more details."
        return 1
    fi
}

doctor_comprehensive() {
    echo "Cortex Doctor (Comprehensive)"
    echo "=============================="
    echo ""

    # Run essential checks first
    doctor_essential
    local essential_status=$?
    echo ""

    echo "Extended Checks"
    echo "---------------"

    # Check 5: ChromaDB collection stats
    echo -n "ChromaDB collection: "
    local stats
    stats=$(curl -sf "http://localhost:${HTTP_PORT}/browse/stats" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local doc_count
        doc_count=$(echo "$stats" | python3 -c "import json,sys; print(json.load(sys.stdin).get('total_documents', 0))" 2>/dev/null)
        echo "OK ($doc_count documents)"
    else
        echo "WARN - Cannot fetch stats"
    fi

    # Check 6: Index/build info
    echo -n "Build info: "
    local info
    info=$(curl -sf "http://localhost:${DAEMON_PORT}/info" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "OK"
        echo "$info" | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(f\"  Commit: {data.get('git_commit', 'unknown')[:7]}\")
print(f\"  Build: {data.get('build_time', 'unknown')}\")
" 2>/dev/null
    else
        echo "WARN - Cannot fetch info"
    fi

    # Check 7: Config file
    echo -n "Config file: "
    if [ -f "$CONFIG_FILE" ]; then
        if python3 -c "import yaml; yaml.safe_load(open('$CONFIG_FILE'))" 2>/dev/null; then
            echo "OK ($CONFIG_FILE)"
        else
            echo "INVALID - YAML parse error"
        fi
    else
        echo "MISSING - Run 'cortex init'"
    fi

    # Check 8: Data directory
    echo -n "Data directory: "
    if [ -d "$DATA_PATH" ]; then
        local data_size
        data_size=$(du -sh "$DATA_PATH" 2>/dev/null | cut -f1)
        echo "OK ($DATA_PATH, $data_size)"
    else
        echo "MISSING"
    fi

    # Check 9: Disk space
    echo -n "Disk space: "
    local available_mb
    available_mb=$(df -m "$DATA_PATH" 2>/dev/null | tail -1 | awk '{print $4}')
    if [ -n "$available_mb" ] && [ "$available_mb" -gt 500 ]; then
        echo "OK (${available_mb}MB available)"
    elif [ -n "$available_mb" ]; then
        echo "WARN - Low disk space (${available_mb}MB)"
    else
        echo "UNKNOWN"
    fi

    # Check 10: Schema version
    echo -n "Schema version: "
    local migration_status
    migration_status=$(curl -sf "http://localhost:${DAEMON_PORT}/migrations/status" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "$migration_status" | python3 -c "
import json, sys
data = json.load(sys.stdin)
current = data.get('current_version', 0)
target = data.get('target_version', 0)
if current == target:
    print(f'OK (v{current})')
else:
    print(f'NEEDS MIGRATION (v{current} -> v{target})')
" 2>/dev/null
    else
        echo "UNKNOWN"
    fi

    # Check 11: Local vs running version
    echo -n "Version sync: "
    local running_commit
    local local_commit
    running_commit=$(curl -sf "http://localhost:${DAEMON_PORT}/info" 2>/dev/null | python3 -c "import json,sys; print(json.load(sys.stdin).get('git_commit','unknown')[:7])" 2>/dev/null || echo "unknown")
    local_commit=$(git -C "$CORTEX_SRC_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    if [ "$running_commit" = "$local_commit" ]; then
        echo "OK (both at $local_commit)"
    elif [ "$running_commit" = "unknown" ] || [ "$local_commit" = "unknown" ]; then
        echo "UNKNOWN"
    else
        echo "OUT OF SYNC (running: $running_commit, local: $local_commit)"
        echo "  Run 'cortex update' to sync"
    fi

    # Check 12: Auto-capture hooks
    echo -n "Auto-capture hooks: "
    python3 -c "
import sys
sys.path.insert(0, '$CORTEX_SRC_DIR')
try:
    from src.install import get_hook_status
    status = get_hook_status()
    if status.claude_code_installed:
        print('OK (Claude Code hook installed)')
    elif status.claude_code_available:
        print('NOT INSTALLED')
        print('  Run \"cortex hooks install\" to enable auto-capture')
    else:
        print('SKIP (Claude CLI not found)')
except Exception as e:
    print(f'ERROR ({e})')
" 2>/dev/null || echo "UNKNOWN"

    # Check 13: LLM Provider
    echo ""
    echo "LLM Provider"
    echo "------------"
    local llm_provider="${CORTEX_LLM_PROVIDER:-${CONFIG_LLM_PROVIDER:-none}}"
    echo "Configured provider: $llm_provider"

    case "$llm_provider" in
        claude-cli)
            # Check if claude CLI is available on host
            echo -n "  Claude CLI: "
            if command -v claude &>/dev/null; then
                echo "OK (found in PATH)"
            else
                echo "NOT FOUND"
                echo "    Install with: npm install -g @anthropic-ai/claude-code"
            fi

            # Check if summarizer proxy is running (needed for Docker mode)
            echo -n "  Summarizer proxy: "
            if is_summarizer_running; then
                local pid
                pid=$(cat "$SUMMARIZER_PID_FILE")
                echo "OK (PID: $pid)"
            else
                echo "NOT RUNNING"
                echo "    Will be started when daemon starts"
            fi

            # Check if summarizer is actually reachable
            echo -n "  Summarizer reachable: "
            if curl -sf "http://localhost:$SUMMARIZER_PORT/health" >/dev/null 2>&1; then
                echo "OK (port $SUMMARIZER_PORT)"
            else
                if is_summarizer_running; then
                    echo "FAIL - Process running but /health unreachable"
                else
                    echo "SKIP - Not running"
                fi
            fi
            ;;
        anthropic)
            echo -n "  ANTHROPIC_API_KEY: "
            if [ -n "$ANTHROPIC_API_KEY" ]; then
                echo "OK (set)"
            else
                echo "NOT SET"
                echo "    Export ANTHROPIC_API_KEY to enable"
            fi
            ;;
        openrouter)
            echo -n "  OPENROUTER_API_KEY: "
            if [ -n "$OPENROUTER_API_KEY" ]; then
                echo "OK (set)"
            else
                echo "NOT SET"
                echo "    Export OPENROUTER_API_KEY to enable"
            fi
            ;;
        ollama)
            echo -n "  Ollama server: "
            if curl -sf "http://localhost:11434/api/version" >/dev/null 2>&1; then
                local ollama_version
                ollama_version=$(curl -sf "http://localhost:11434/api/version" | python3 -c "import json,sys; print(json.load(sys.stdin).get('version','unknown'))" 2>/dev/null)
                echo "OK (v$ollama_version)"
            else
                echo "NOT REACHABLE"
                echo "    Start Ollama or check if it's running on localhost:11434"
            fi
            ;;
        none)
            echo "  No LLM provider configured"
            echo "  Auto-capture summarization will be disabled"
            echo "  Set llm.primary_provider in ~/.cortex/config.yaml"
            ;;
        *)
            echo "  Unknown provider: $llm_provider"
            ;;
    esac

    echo ""
    return $essential_status
}

# --- CLI Commands (bypass LLM) ---

cli_search() {
    local query="$*"
    if [ -z "$query" ]; then
        echo "Usage: cortex search <query>" >&2
        echo "Example: cortex search authentication flow" >&2
        exit 1
    fi

    if ! is_daemon_running; then
        echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
        exit 1
    fi

    # URL-encode the query
    local encoded_query
    encoded_query=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$query'))")

    # Call the HTTP API
    local response
    response=$(curl -sf "http://localhost:${HTTP_PORT}/search?q=${encoded_query}&limit=5")

    if [ $? -ne 0 ]; then
        echo "Error: Search failed. Is the daemon running?" >&2
        exit 1
    fi

    # Pretty-print results
    echo "$response" | python3 -c "
import json
import sys

try:
    data = json.load(sys.stdin)
    query = data.get('query', '')
    results = data.get('results', [])
    timing = data.get('timing_ms', 0)

    print(f'Search: \"{query}\" ({len(results)} results, {timing}ms)')
    print()

    if not results:
        print('No results found.')
    else:
        for i, r in enumerate(results, 1):
            meta = r.get('metadata', {})
            score = r.get('score', 0)
            content = r.get('content', '')[:200]

            # Format source
            source = meta.get('file_path', meta.get('url', meta.get('project', 'unknown')))
            doc_type = meta.get('type', 'unknown')

            print(f'{i}. [{doc_type}] {source}')
            print(f'   Score: {score:.3f}')
            print(f'   {content}...')
            print()
except Exception as e:
    print(f'Error parsing response: {e}', file=sys.stderr)
    sys.exit(1)
"
}

cli_save() {
    # Parse options
    local title=""
    local project="notes"
    local tags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--title)
                title="$2"
                shift 2
                ;;
            -p|--project)
                project="$2"
                shift 2
                ;;
            --tags)
                tags="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Unknown option: $1" >&2
                echo "Usage: cortex save [-t title] [-p project] [--tags tag1,tag2] <content>" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done

    local content="$*"
    if [ -z "$content" ]; then
        echo "Usage: cortex save [-t title] [-p project] [--tags tag1,tag2] <content>" >&2
        echo "Example: cortex save -t 'Auth Decision' 'We chose JWT for auth because...'" >&2
        exit 1
    fi

    if ! is_daemon_running; then
        echo "Error: Daemon is not running. Start with: cortex daemon start" >&2
        exit 1
    fi

    # Build JSON payload
    local json_payload
    json_payload=$(python3 -c "
import json
payload = {
    'content': '''$content''',
    'project': '$project'
}
if '$title':
    payload['title'] = '$title'
if '$tags':
    payload['tags'] = '$tags'.split(',')
print(json.dumps(payload))
")

    # Call the HTTP API
    local response
    response=$(curl -sf -X POST \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        "http://localhost:${HTTP_PORT}/note")

    if [ $? -ne 0 ]; then
        echo "Error: Save failed. Is the daemon running?" >&2
        exit 1
    fi

    # Show result
    echo "$response" | python3 -c "
import json
import sys
data = json.load(sys.stdin)
if data.get('status') == 'success':
    title = data.get('title', '(untitled)')
    doc_id = data.get('id', 'unknown')
    print(f'Saved: {title}')
    print(f'ID: {doc_id}')
else:
    print('Save failed', file=sys.stderr)
    sys.exit(1)
"
}

# --- Help Command ---

show_help() {
    cat <<'EOF'
Cortex - AI-powered codebase memory for Claude Code

USAGE:
    cortex [COMMAND]

COMMANDS:
    (default)           Start MCP bridge (auto-starts daemon if needed)
    search <query>      Search memory directly (bypasses LLM)
    save [opts] <text>  Save a note directly (bypasses LLM)
                        Options: -t <title>, -p <project>, --tags <a,b>
    update              Update Cortex (pull, rebuild, migrate, restart)
    doctor              Check system health (add --verbose for full check)
    init                Interactive setup, creates ~/.cortex/config.yaml
    config              Show current configuration
    config edit         Open config.yaml in $EDITOR
    hooks install       Install auto-capture hooks (add -f to force reinstall)
    hooks status        Show hook installation status
    hooks repair        Reinstall hooks from latest source
    hooks uninstall     Remove hooks and disable auto-capture
    daemon start        Start the daemon container
    daemon stop         Stop the daemon container
    daemon restart      Restart the daemon (rebuilds image)
    daemon status       Check daemon status and build info
    daemon logs         View daemon logs (follows output)
    daemon rebuild      Stop, rebuild image, and restart daemon
    stop                Shortcut for 'daemon stop'
    logs                Shortcut for 'daemon logs'
    rebuild             Shortcut for 'daemon rebuild'
    help, --help, -h    Show this help message

CONFIGURATION:
    Configuration is stored at ~/.cortex/config.yaml
    Run 'cortex init' to create this file interactively.

    Config file options:
      code_paths        List of directories to mount (e.g., ["~/Projects"])
      debug             true or false
      daemon_port       Daemon port for MCP communication (default: 8000)
      http_port         HTTP debug server port (default: 8080)
      llm               LLM provider settings for summarization
      autocapture       Auto-capture settings for session memory

ENVIRONMENT VARIABLES (override config.yaml):
    CORTEX_CODE_PATHS       Comma-separated list of code directories
    CORTEX_DEBUG            Enable debug logging (true/false)
    CORTEX_DAEMON_PORT      Daemon port (default: 8000)
    CORTEX_HTTP_PORT        HTTP debug server port (default: 8080)
    CORTEX_LLM_PROVIDER     LLM provider: anthropic, claude-cli, ollama, openrouter, none
    ANTHROPIC_API_KEY       Required for llm.primary_provider="anthropic"
    OPENROUTER_API_KEY      Required for llm.primary_provider="openrouter"

QUICK START:
    1. Run 'cortex init' to configure your settings
    2. Start the daemon: cortex daemon start
    3. Add to Claude Code: claude mcp add cortex cortex --scope user
    4. Restart Claude Code to load the MCP server

EXAMPLES:
    cortex init                 # First-time setup
    cortex                      # Start MCP server (normal usage)
    cortex search auth flow     # Quick search from terminal
    cortex save "Use JWT"       # Save a quick note
    cortex save -t "Decision" "We chose Redis for caching"
    cortex daemon status        # Check if daemon is healthy
    cortex daemon logs          # Debug issues
    cortex config edit          # Modify config
    cortex daemon restart       # Apply config changes

For more information, see: https://github.com/anthropics/cortex
EOF
}

# --- Main Command Handling ---

case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    daemon)
        case "${2:-status}" in
            start)
                build_image_if_needed
                start_daemon
                ;;
            stop)
                stop_daemon
                ;;
            restart)
                stop_daemon
                build_image
                start_daemon
                ;;
            status)
                daemon_status
                ;;
            logs)
                daemon_logs
                ;;
            rebuild)
                stop_daemon
                build_image
                start_daemon
                ;;
            *)
                echo "Usage: cortex daemon {start|stop|restart|status|logs|rebuild}" >&2
                exit 1
                ;;
        esac
        ;;
    init)
        init_config
        ;;
    config)
        case "${2:-}" in
            edit)
                edit_config
                ;;
            ""|show)
                show_config
                ;;
            *)
                echo "Usage: cortex config [show|edit]" >&2
                exit 1
                ;;
        esac
        ;;
    stop)
        stop_daemon
        ;;
    logs)
        daemon_logs
        ;;
    rebuild)
        stop_daemon
        build_image
        start_daemon
        ;;
    search)
        shift
        cli_search "$@"
        ;;
    save)
        shift
        cli_save "$@"
        ;;
    update)
        do_update
        ;;
    hooks)
        case "${2:-status}" in
            install)
                hooks_install "${3:-}"
                ;;
            status)
                hooks_status
                ;;
            repair)
                hooks_repair
                ;;
            uninstall)
                hooks_uninstall
                ;;
            *)
                echo "Usage: cortex hooks {install|status|repair|uninstall}" >&2
                echo "" >&2
                echo "Commands:" >&2
                echo "  install    Install hooks for auto-capture (add -f to force reinstall)" >&2
                echo "  status     Show current hook installation status" >&2
                echo "  repair     Reinstall hooks from latest source" >&2
                echo "  uninstall  Remove hooks and disable auto-capture" >&2
                exit 1
                ;;
        esac
        ;;
    doctor)
        if [ "${2:-}" = "--verbose" ] || [ "${2:-}" = "-v" ]; then
            doctor_comprehensive
        else
            doctor_essential
        fi
        ;;
    "")
        # No arguments: run stdio bridge (auto-starts daemon if needed)
        run_bridge
        ;;
    *)
        # Unknown command
        echo "Error: Unknown command '$1'" >&2
        echo "" >&2
        echo "Run 'cortex help' for usage information." >&2
        exit 1
        ;;
esac
